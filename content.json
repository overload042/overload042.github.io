{"meta":{"title":"梁山好岗のBLOG","subtitle":"就算是梦话也无妨，再说给我听听吧","description":"站点描述","author":"梁山好岗","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T07:01:20.000Z","updated":"2020-05-04T07:04:46.242Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T07:01:36.000Z","updated":"2020-05-04T07:05:32.380Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-04T07:01:49.000Z","updated":"2020-05-04T07:06:03.220Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java学习日记21——单元测试及反射&注解","slug":"Java学习日记21——单元测试及反射&注解","date":"2020-07-25T04:17:11.792Z","updated":"2020-07-25T11:52:41.822Z","comments":true,"path":"2020/07/25/Java学习日记21——单元测试及反射&注解/","link":"","permalink":"http://yoursite.com/2020/07/25/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B021%E2%80%94%E2%80%94%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3/","excerpt":"Java学习每一天","text":"Java学习每一天 Junit单元测试测试分为黑盒测试和白盒测试。 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit单元测试是白盒测试。 使用步骤 定义一个测试类(测试用例) 建议：* 测试类名：被测试的类名Test CalculatorTest 包名：xxx.xxx.xx.test cn.itcast.test 定义测试方法：可以独立运行 建议：* 方法名：test测试的方法名 testAdd() 返回值：void 参数列表：空参 举例: 123456789@Testpublic void testSub()&#123; //1.创建计算器对象 Calculator c = new Calculator(); int result = c.sub(1, 2); System.out.println(\"testSub....\"); // 断言 1-2 等于 -1 Assert.assertEquals(-1,result);&#125; 给方法加@Test 导入junit依赖环境 判定结果我们并从打印结果判断代码是否错误，而是通过执行结果判断。 判定结果：* 红色：失败 绿色：成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(期望的结果,运算的结果); 上面的举例中已经使用了断言。 补充 @Before：修饰的方法会在测试方法之前被自动执行。 初始化方法 @After：修饰的方法会在测试方法执行之后自动被执行。 释放资源方法 反射：框架设计的灵魂认识反射框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其他对象，这就是反射机制 封装的对象主要有Field、Constructor和Method三部分。 反射的好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 获取Class对象三种方法： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 举例： 12//1.Class.forName(\"全类名\")Class cls1 = Class.forName(\"cn.itcast.domain.Person\"); 注意：多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 举例： 1Class cls2 = Person.class; 注意：多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 举例： 12Person p = new Person();Class cls3 = p.getClass(); 注意：多用于对象的获取字节码的方式 注意：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 封装对象Field：成员变量获取成员变量 Field[] getFields()：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 1234567891011121314151617181920 // 获取Person的Class对象 Class personClass = Person.class;// Field[] getFields()获取所有public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field field : fields) &#123; System.out.println(field); &#125;// Field getField(String name) Field a = personClass.getField(\"a\");// Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); &#125;// Field getDeclaredField(String name) Field d = personClass.getDeclaredField(\"d\"); 成员变量方法 void set(Object obj, Object value) 设置值 get(Object obj) 获取值 setAccessible(true) 暴力反射 123456789101112131415 // 获取Person的Class对象 Class personClass = Person.class; // 获取成员变量 Field a = personClass.getField(\"a\"); //获取成员变量a 的值 Person p = new Person(); Object value = a.get(p); System.out.println(value); //设置a的值 a.set(p,\"张三\"); System.out.println(p);// 如果a是由getDeclaredField方法获取的私有成员变量，则需先对a暴力反射，再对其操作。 // 暴力反射 a.setAccessible(true); Constructor：构造方法获取构造方法 Constructor&lt;?&gt;[] getConstructors() Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 使用方法同获取成员变量 构造方法使用 T newInstance(Object... initargs) 创建对象 注意：如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 1234567891011121314// 获取Person的Class对象 Class personClass = Person.class; // 获取构造方法 Constructor constructor = personClass.getConstructor(String.class, int.class); // 构造方法使用 Object person = constructor.newInstance(\"张三\", 23); System.out.println(person);// 空参构造省略写法 Object o = personClass.newInstance(); System.out.println(o);// 构造方法也有暴力反射 //constructor.setAccessible(true); Method：成员方法获取成员方法 Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 使用方法同获取成员变量 成员方法使用 Object invoke(Object obj, Object... args) 执行方法 String getName 获取方法名称 123456789101112131415161718192021222324252627282930 // 获取Person的Class对象 Class personClass = Person.class; // 获取指定名称的方法 Method eat_method = personClass.getMethod(\"eat\"); Person p = new Person(); // 执行方法 eat_method.invoke(p); // 获取带参数的方法 Method eat_method2 = personClass.getMethod(\"eat\", String.class); // 执行方法 eat_method2.invoke(p,\"饭\"); System.out.println(\"-----------------\"); //获取所有public修饰的方法 Method[] methods = personClass.getMethods(); // 遍历方法名 for (Method method : methods) &#123; System.out.println(method); String name = method.getName(); System.out.println(name); // 成员方法也有暴力反射 //method.setAccessible(true); &#125;// -------------------------补充---------------------------------- //获取类名 String className = personClass.getName(); System.out.println(className);//cn.itcast.domain.Person 编写框架案例* 案例： * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法1234567891011121314151617181920212223242526272829303132public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //可以创建任意类的对象，可以执行任意方法 /* 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法 */ //1.加载配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录下的配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(\"pro.properties\"); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty(\"className\"); String methodName = pro.getProperty(\"methodName\"); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125; 注解定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： JDK1.5之后的新特性 说明程序的 使用注解：@注解名称 作用： 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 预定义注解 @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告 一般传递参数all @SuppressWarnings(“all”) 自定义注解本质：注解本质上就是一个接口，该接口默认继承Annotation接口。 1public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; 格式1234元注解public @interface 注解名称&#123; 属性列表;&#125; 属性属性就是接口中的抽象方法。 返回值要求： 基本数据类型 String 枚举 注解 以上类型的数组 赋值： 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解元注解是用于描述注解的注解 @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 获取注解中定义的属性值 获取注解定义的位置的对象 （Class，Method,Field） 获取指定的注解 getAnnotation(Class)12345678910&#x2F;&#x2F; getAnnotation(Class)&#x2F;&#x2F; 其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro&#123; public String className()&#123; return &quot;cn.itcast.annotation.Demo1&quot;; &#125; public String methodName()&#123; return &quot;show&quot;; &#125; &#125; 调用注解中的抽象方法获取配置的属性值 使用不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法 123456789101112131415161718192021222324@Pro(className = \"cn.itcast.annotation.Demo1\",methodName = \"show\")public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; //1.解析注解 //1.1获取该类的字节码文件对象 Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class; //2.获取上边的注解对象 Pro an = reflectTestClass.getAnnotation(Pro.class); //3.调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); String methodName = an.methodName(); System.out.println(className); System.out.println(methodName); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); &#125;&#125; 案例当主方法执行后，会自动自行被检测的所有方法(加了Check注解的方法)，判断方法是否有异常，记录到文件中 自定义注解 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Check &#123;&#125; 需要测试的方法 12345678910111213141516171819202122232425262728293031public class Calculator &#123; //加法 @Check public void add()&#123; String str = null; str.toString(); System.out.println(\"1 + 0 =\" + (1 + 0)); &#125; //减法 @Check public void sub()&#123; System.out.println(\"1 - 0 =\" + (1 - 0)); &#125; //乘法 @Check public void mul()&#123; System.out.println(\"1 * 0 =\" + (1 * 0)); &#125; //除法 @Check public void div()&#123; System.out.println(\"1 / 0 =\" + (1 / 0)); &#125; public void show()&#123; System.out.println(\"永无bug...\"); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestCheck &#123; public static void main(String[] args) throws IOException &#123; //1.创建计算器对象 Calculator c = new Calculator(); //2.获取字节码文件对象 Class cls = c.getClass(); //3.获取所有方法 Method[] methods = cls.getMethods(); int number = 0;//出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(\"bug.txt\")); for (Method method : methods) &#123; //4.判断方法上是否有Check注解 if(method.isAnnotationPresent(Check.class))&#123; //5.有，执行 try &#123; method.invoke(c); &#125; catch (Exception e) &#123; //6.捕获异常 //记录到文件中 number ++; bw.write(method.getName()+ \" 方法出异常了\"); bw.newLine(); bw.write(\"异常的名称:\" + e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(\"异常的原因:\"+e.getCause().getMessage()); bw.newLine(); bw.write(\"--------------------------\"); bw.newLine(); &#125; &#125; &#125; bw.write(\"本次测试一共出现 \"+number+\" 次异常\"); bw.flush(); bw.close(); &#125;&#125; 小结 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记20——Stream流、方法引用","slug":"Java学习日记20——Stream流、方法引用","date":"2020-07-21T06:12:24.650Z","updated":"2020-07-21T07:38:17.510Z","comments":true,"path":"2020/07/21/Java学习日记20——Stream流、方法引用/","link":"","permalink":"http://yoursite.com/2020/07/21/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B020%E2%80%94%E2%80%94Stream%E6%B5%81%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"Java学习每一天","text":"Java学习每一天 Stream流流式思想概述整体来看，流式思想类似于工厂车间的“生产流水线”。 这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。 这里的filter、map、skip都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法count执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。 备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 Stream（流）是一个来自数据源的元素队列 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源 流的来源。 可以是集合，数组 等。 和以前的Collection操作不同， Stream操作还有两个基础的特征： Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。 获取流java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 根据Collection获取流java.util.Collection接口中加入了default方法stream用来获取流，所以其所有实现类均可获取流。 123456789101112131415161718import java.util.*;import java.util.stream.Stream;public class Demo04GetStream &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // ... Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); // ... Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); // ... Stream&lt;String&gt; stream3 = vector.stream(); &#125;&#125; 根据Map获取流java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 12345678910111213import java.util.HashMap;import java.util.Map;import java.util.stream.Stream;public class Demo05GetStream &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // ... Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125;&#125; 根据数组获取流如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以Stream接口中提供了静态方法of，使用很简单： 1234567891011import java.util.stream.Stream;public class Demo06GetStream &#123; public static void main(String[] args) &#123; String[] array = &#123; \"张无忌\", \"张翠山\", \"张三丰\", \"张一元\" &#125;; Stream&lt;String&gt; stream = Stream.of(array); //可变参数可以传递数组 Stream&lt;Integer&gt; stream6 = Stream.of(1, 2, 3, 4, 5); &#125;&#125; 备注：of方法的参数其实是一个可变参数，所以支持数组。 常用方法方法可以被分成两种： 延迟方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。） 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 备注：本小节之外的更多方法，请自行参考API文档。 逐一处理：forEach作用：用来遍历流中的数据。 1void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。 使用： 123456789101112public class Demo02Stream_forEach &#123; public static void main(String[] args) &#123; //获取一个Stream流 Stream&lt;String&gt; stream = Stream.of(\"张三\", \"李四\", \"王五\", \"赵六\", \"田七\"); //使用Stream流中的方法forEach对Stream流中的数据进行遍历 /*stream.forEach((String name)-&gt;&#123; System.out.println(name); &#125;);*/ stream.forEach(name-&gt;System.out.println(name)); &#125;&#125; 过滤：filter作用：过滤掉不符合条件的元素 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个Predicate函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 使用 1234567891011121314151617181920public class Demo03Stream_filter &#123; public static void main(String[] args) &#123; //创建一个Stream流 Stream&lt;String&gt; stream = Stream.of(\"张三丰\", \"张翠山\", \"赵敏\", \"周芷若\", \"张无忌\"); //对Stream流中的元素进行过滤,只要姓张的人 Stream&lt;String&gt; stream2 = stream.filter((String name)-&gt;&#123;return name.startsWith(\"张\");&#125;); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); /* Stream流属于管道流,只能被消费(使用)一次 第一个Stream流调用完毕方法,数据就会流转到下一个Stream上 而这时第一个Stream流已经使用完毕,就会关闭了 所以第一个Stream流就不能再调用方法了 IllegalStateException: stream has already been operated upon or closed */ //遍历stream流 stream.forEach(name-&gt; System.out.println(name)); &#125;&#125; 映射：map作用：如果需要将流中的元素映射到另一个流中。 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 使用 123456789101112public class Demo04Stream_map &#123; public static void main(String[] args) &#123; //获取一个String类型的Stream流 Stream&lt;String&gt; stream = Stream.of(\"1\", \"2\", \"3\", \"4\"); //使用map方法,把字符串类型的整数,转换(映射)为Integer类型的整数 Stream&lt;Integer&gt; stream2 = stream.map((String s)-&gt;&#123; return Integer.parseInt(s); &#125;); //遍历Stream2流 stream2.forEach(i-&gt; System.out.println(i)); &#125;&#125; 统计个数：count作用：正如旧集合Collection当中的size方法一样，流提供count方法来数一数其中的元素个数： 1long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。 使用： 12345678910111213141516public class Demo05Stream_count &#123; public static void main(String[] args) &#123; //获取一个Stream流 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); list.add(7); Stream&lt;Integer&gt; stream = list.stream(); long count = stream.count(); System.out.println(count);//7 &#125;&#125; 取用前几个：limit作用：limit方法可以对流进行截取，只取用前n个。 1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。 使用 1234567891011public class Demo06Stream_limit &#123; public static void main(String[] args) &#123; //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream = Stream.of(arr); //使用limit对Stream流中的元素进行截取,只要前3个元素 Stream&lt;String&gt; stream2 = stream.limit(3); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); &#125;&#125; 跳过前几个：skip作用：跳过前几个元素，获取后面的元素。 1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用： 1234567891011public class Demo07Stream_skip &#123; public static void main(String[] args) &#123; //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream = Stream.of(arr); //使用skip方法跳过前3个元素 Stream&lt;String&gt; stream2 = stream.skip(3); //遍历stream2流 stream2.forEach(name-&gt; System.out.println(name)); &#125;&#125; 组合：concat作用：把两个流合并成为一个流。 1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 备注：这是一个静态方法，与java.lang.String当中的concat方法是不同的。 使用 12345678910111213public class Demo08Stream_concat &#123; public static void main(String[] args) &#123; //创建一个Stream流 Stream&lt;String&gt; stream1 = Stream.of(\"张三丰\", \"张翠山\", \"赵敏\", \"周芷若\", \"张无忌\"); //获取一个Stream流 String[] arr = &#123;\"美羊羊\",\"喜洋洋\",\"懒洋洋\",\"灰太狼\",\"红太狼\"&#125;; Stream&lt;String&gt; stream2 = Stream.of(arr); //把以上两个流组合为一个流 Stream&lt;String&gt; concat = Stream.concat(stream1, stream2); //遍历concat流 concat.forEach(name-&gt; System.out.println(name)); &#125;&#125; 方法引用在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 方法引用符：:: 通过对象名引用成员方法已有有对象和方法。 定义一个打印的函数式接口 12345@FunctionalInterfacepublic interface Printable &#123; //定义字符串的抽象方法 void print(String s);&#125; 定义一个类 123456public class MethodRerObject &#123; //定义一个成员方法,传递字符串,把字符串按照大写输出 public void printUpperCaseString(String str)&#123; System.out.println(str.toUpperCase()); &#125;&#125; 使用 1234567891011121314151617181920212223242526public class Demo01ObjectMethodReference &#123; //定义一个方法,方法的参数传递Printable接口 public static void printString(Printable p)&#123; p.print(\"Hello\"); &#125; public static void main(String[] args) &#123; //调用printString方法,方法的参数Printable是一个函数式接口,所以可以传递Lambda表达式 printString((s)-&gt;&#123; //创建MethodRerObject对象 MethodRerObject obj = new MethodRerObject(); //调用MethodRerObject对象中的成员方法printUpperCaseString,把字符串按照大写输出 obj.printUpperCaseString(s); &#125;); /* 使用方法引用优化Lambda 对象是已经存在的MethodRerObject 成员方法也是已经存在的printUpperCaseString 所以我们可以使用对象名引用成员方法 */ //创建MethodRerObject对象 MethodRerObject obj = new MethodRerObject(); printString(obj::printUpperCaseString); &#125;&#125; 通过类名称引用静态方法类已经存在,静态成员方法也已经存在。 由于在java.lang.Math类中已经存在了静态方法abs，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口： 12345@FunctionalInterfacepublic interface Calcable &#123; //定义一个抽象方法,传递一个整数,对整数进行绝对值计算并返回 int calsAbs(int number);&#125; 通过类名直接引用静态成员方法 123456789101112131415161718192021222324public class Demo01StaticMethodReference &#123; //定义一个方法,方法的参数传递要计算绝对值的整数,和函数式接口Calcable public static int method(int number,Calcable c)&#123; return c.calsAbs(number); &#125; public static void main(String[] args) &#123; //调用method方法,传递计算绝对值得整数,和Lambda表达式 int number = method(-10,(n)-&gt;&#123; //对参数进行绝对值得计算并返回结果 return Math.abs(n); &#125;); System.out.println(number); /* 使用方法引用优化Lambda表达式 Math类是存在的 abs计算绝对值的静态方法也是已经存在的 所以我们可以直接通过类名引用静态方法 */ int number2 = method(-10,Math::abs); System.out.println(number2); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：n -&gt; Math.abs(n) 方法引用：Math::abs 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口： 12345@FunctionalInterfacepublic interface Greetable &#123; //定义一个见面的方法 void greet();&#125; 然后是父类Human的内容： 123456public class Human &#123; //定义一个sayHello的方法 public void sayHello()&#123; System.out.println(\"Hello 我是Human!\"); &#125;&#125; 最后是子类Man的内容，其中使用了Lambda的写法： 123456789101112131415161718192021222324252627282930313233343536373839public class Man extends Human&#123; //子类重写父类sayHello的方法 @Override public void sayHello() &#123; System.out.println(\"Hello 我是Man!\"); &#125; //定义一个方法参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; //调用method方法,方法的参数Greetable是一个函数式接口,所以可以传递Lambda /*method(()-&gt;&#123; //创建父类Human对象 Human h = new Human(); //调用父类的sayHello方法 h.sayHello(); &#125;);*/ //因为有子父类关系,所以存在的一个关键字super,代表父类,所以我们可以直接使用super调用父类的成员方法 /* method(()-&gt;&#123; super.sayHello(); &#125;);*/ /* 使用super引用类的成员方法 super是已经存在的 父类的成员方法sayHello也是已经存在的 所以我们可以直接使用super引用父类的成员方法 */ method(super::sayHello); &#125; public static void main(String[] args) &#123; new Man().show(); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：() -&gt; super.sayHello() 方法引用：super::sayHello 通过this引用成员方法this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方法引用。首先是简单的函数式接口： 12345@FunctionalInterfacepublic interface Richable &#123; //定义一个想买什么就买什么的方法 void buy();&#125; 下面是一个丈夫Husband类： 1234567891011121314151617181920212223242526272829303132public class Husband &#123; //定义一个买房子的方法 public void buyHouse()&#123; System.out.println(\"北京二环内买一套四合院!\"); &#125; //定义一个结婚的方法,参数传递Richable接口 public void marry(Richable r)&#123; r.buy(); &#125; //定义一个非常高兴的方法 public void soHappy()&#123; //调用结婚的方法,方法的参数Richable是一个函数式接口,传递Lambda表达式 /* marry(()-&gt;&#123; //使用this.成员方法,调用本类买房子的方法 this.buyHouse(); &#125;);*/ /* 使用方法引用优化Lambda表达式 this是已经存在的 本类的成员方法buyHouse也是已经存在的 所以我们可以直接使用this引用本类的成员方法buyHouse */ marry(this::buyHouse); &#125; public static void main(String[] args) &#123; new Husband().soHappy(); &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：() -&gt; this.buyHouse() 方法引用：this::buyHouse 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名称::new的格式表示。首先是一个简单的Person类： 123456789101112131415161718public class Person &#123; private String name; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后是用来创建Person对象的函数式接口： 12345@FunctionalInterfacepublic interface PersonBuilder &#123; //定义一个方法,根据传递的姓名,创建Person对象返回 Person builderPerson(String name);&#125; 使用这个函数式接口 12345678910111213141516171819202122public class Demo &#123; //定义一个方法,参数传递姓名和PersonBuilder接口,方法中通过姓名创建Person对象 public static void printName(String name,PersonBuilder pb)&#123; Person person = pb.builderPerson(name); System.out.println(person.getName()); &#125; public static void main(String[] args) &#123; //调用printName方法,方法的参数PersonBuilder接口是一个函数式接口,可以传递Lambda printName(\"迪丽热巴\",(String name)-&gt;&#123; return new Person(name); &#125;); /* 使用方法引用优化Lambda表达式 构造方法new Person(String name) 已知 创建对象已知 new 就可以使用Person引用new创建对象 */ printName(\"古力娜扎\",Person::new);//使用Person类的带参构造方法,通过传递的姓名创建对象 &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：name -&gt; new Person(name) 方法引用：Person::new 数组的构造器引用数组也是Object的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，需要一个函数式接口： 12345@FunctionalInterfacepublic interface ArrayBuilder &#123; //定义一个创建int类型数组的方法,参数传递数组的长度,返回创建好的int类型数组 int[] builderArray(int length);&#125; 应用该接口 123456789101112131415161718192021222324252627282930public class Demo &#123; /* 定义一个方法 方法的参数传递创建数组的长度和ArrayBuilder接口 方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回 */ public static int[] createArray(int length, ArrayBuilder ab)&#123; return ab.builderArray(length); &#125; public static void main(String[] args) &#123; //调用createArray方法,传递数组的长度和Lambda表达式 int[] arr1 = createArray(10,(len)-&gt;&#123; //根据数组的长度,创建数组并返回 return new int[len]; &#125;); System.out.println(arr1.length);//10 /* 使用方法引用优化Lambda表达式 已知创建的就是int[]数组 数组的长度也是已知的 就可以使用方法引用 int[]引用new,根据参数传递的长度来创建数组 */ int[] arr2 =createArray(10,int[]::new); System.out.println(Arrays.toString(arr2)); System.out.println(arr2.length);//10 &#125;&#125; 在这个例子中，下面两种写法是等效的： Lambda表达式：length -&gt; new int[length] 方法引用：int[]::new","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记19——函数式接口","slug":"Java学习日记19——函数式接口","date":"2020-07-20T12:50:10.142Z","updated":"2020-07-20T13:52:03.152Z","comments":true,"path":"2020/07/20/Java学习日记19——函数式接口/","link":"","permalink":"http://yoursite.com/2020/07/20/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B019%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"Java学习每一天","text":"Java学习每一天 函数式接口函数式接口在Java中是指：有且仅有一个抽象方法的接口。 函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。 备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。 格式只要确保接口中有且仅有一个抽象方法即可： 1234修饰符 interface 接口名称 &#123; public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; @FunctionalInterface注解与@Override注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。该注解可用于一个接口的定义上： 1234@FunctionalInterfacepublic interface MyFunctionalInterface &#123; void myMethod();&#125; 一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。 示例对于刚刚定义好的MyFunctionalInterface函数式接口，典型使用场景就是作为方法的参数： 1234567891011public class Demo09FunctionalInterface &#123; // 使用自定义的函数式接口作为方法参数 private static void doSomething(MyFunctionalInterface inter) &#123; inter.myMethod(); // 调用自定义的函数式接口方法 &#125; public static void main(String[] args) &#123; // 调用使用函数式接口的方法 doSomething(() -&gt; System.out.println(\"Lambda执行啦！\")); &#125;&#125; 函数式编程Lambda的延迟执行有些场景的代码执行后，结果不一用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 日志案例1234567891011121314151617181920public class Demo01Logger &#123; //定义一个根据日志的级别,显示日志信息的方法 public static void showLog(int level, String message)&#123; //对日志的等级进行判断,如果是1级别,那么输出日志信息 if(level==1)&#123; System.out.println(message); &#125; &#125; public static void main(String[] args) &#123; //定义三个日志信息 String msg1 = \"Hello\"; String msg2 = \"World\"; String msg3 = \"Java\"; //调用showLog方法,传递日志级别和日志信息 showLog(2,msg1+msg2+msg3); &#125;&#125; showLog方法中如果传递的日志等级不是1级，那么就不会是如此拼接后的字符串，所以感觉字符串就白拼接了，存在了浪费 Lambda优化写法使用Lambda必然需要一个函数式接口： 12345@FunctionalInterfacepublic interface MessageBuilder &#123; //定义一个拼接消息的抽象方法,返回被拼接的消息 public abstract String builderMessage();&#125; 优化代码： 1234567891011121314151617181920212223242526272829303132333435363738public class Demo02Lambda &#123; //定义一个显示日志的方法,方法的参数传递日志的等级和MessageBuilder接口 public static void showLog(int level, MessageBuilder mb)&#123; //对日志的等级进行判断,如果是1级,则调用MessageBuilder接口中的builderMessage方法 if(level==1)&#123; System.out.println(mb.builderMessage()); &#125; &#125; public static void main(String[] args) &#123; //定义三个日志信息 String msg1 = \"Hello\"; String msg2 = \"World\"; String msg3 = \"Java\"; //调用showLog方法,参数MessageBuilder是一个函数式接口,所以可以传递Lambda表达式 /*showLog(2,()-&gt;&#123; //返回一个拼接好的字符串 return msg1+msg2+msg3; &#125;);*/ /* 使用Lambda表达式作为参数传递,仅仅是把参数传递到showLog方法中 只有满足条件,日志的等级是1级 才会调用接口MessageBuilder中的方法builderMessage 才会进行字符串的拼接 如果条件不满足,日志的等级不是1级 那么MessageBuilder接口中的方法builderMessage也不会执行 所以拼接字符串的代码也不会执行 所以不会存在性能的浪费 */ showLog(1,()-&gt;&#123; System.out.println(\"不满足条件不执行\"); //返回一个拼接好的字符串 return msg1+msg2+msg3; &#125;); &#125;&#125; 这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。 扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调用其所在方法是在条件判断之后才执行的。 Lambda—&gt;线程和排序 线程 java.lang.Runnable接口就是一个函数式接口，假设有一个startThread方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和Thread类的构造方法参数为Runnable没有本质区别。 123456789public class Demo04Runnable &#123; private static void startThread(Runnable task) &#123; new Thread(task).start(); &#125; public static void main(String[] args) &#123; startThread(() -&gt; System.out.println(\"线程任务执行！\")); &#125;&#125; 排序 java.util.Comparator`接口类型的对象作为排序器就可以使用Lambda获取。 12345678910111213141516171819202122232425262728293031323334public class Demo02Comparator &#123; //定义一个方法,方法的返回值类型使用函数式接口Comparator public static Comparator&lt;String&gt; getComparator()&#123; //方法的返回值类型是一个接口,那么我们可以返回这个接口的匿名内部类 /*return new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; //按照字符串的降序排序 return o2.length()-o1.length(); &#125; &#125;;*/ //方法的返回值类型是一个函数式接口,所有我们可以返回一个Lambda表达式 /*return (String o1, String o2)-&gt;&#123; //按照字符串的降序排序 return o2.length()-o1.length(); &#125;;*/ //继续优化Lambda表达式 return (o1, o2)-&gt;o2.length()-o1.length(); &#125; public static void main(String[] args) &#123; //创建一个字符串数组 String[] arr = &#123;\"aaa\",\"b\",\"cccccc\",\"dddddddddddd\"&#125;; //输出排序前的数组 System.out.println(Arrays.toString(arr));//[aaa, b, cccccc, dddddddddddd] //调用Arrays中的sort方法,对字符串数组进行排序 Arrays.sort(arr,getComparator()); //输出排序后的数组 System.out.println(Arrays.toString(arr));//[dddddddddddd, cccccc, aaa, b] &#125;&#125; 常用函数式接口Supplier接口java.util.function.Supplier&lt;T&gt;接口仅包含一个无参的方法：T get()。 作用：用来获取一个泛型参数指定类型的对象数据。 使用 12345678910111213141516171819public class Demo01Supplier &#123; //定义一个方法,方法的参数传递Supplier&lt;T&gt;接口,泛型执行String,get方法就会返回一个String public static String getString(Supplier&lt;String&gt; sup)&#123; return sup.get(); &#125; public static void main(String[] args) &#123; //调用getString方法,方法的参数Supplier是一个函数式接口,所以可以传递Lambda表达式 String s = getString(()-&gt;&#123; //生产一个字符串,并返回 return \"胡歌\"; &#125;); System.out.println(s); //优化Lambda表达式 String s2 = getString(()-&gt;\"胡歌\"); System.out.println(s2); &#125;&#125; Consumer接口java.util.function.Consumer&lt;T&gt;：消费一个数据，其数据类型由泛型决定。 抽象方法：acceptConsumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。 使用 123456789101112131415161718public class Demo01Consumer &#123; public static void method(String name, Consumer&lt;String&gt; con)&#123; con.accept(name); &#125; public static void main(String[] args) &#123; //调用method方法,传递字符串姓名,方法的另一个参数是Consumer接口,是一个函数式接口,所以可以传递Lambda表达式 method(\"赵丽颖\",(String name)-&gt;&#123; //对传递的字符串进行消费 //消费方式:直接输出字符串 //System.out.println(name); //消费方式:把字符串进行反转输出 String reName = new StringBuffer(name).reverse().toString(); System.out.println(reName); &#125;); &#125;&#125; 当然，更好的写法是使用方法引用。 默认方法：andThen作用：需要两个Consumer接口,可以把两个Consumer接口组合到一起,在对数据进行消费 使用 12345678910111213141516171819202122public class Demo02AndThen &#123; //定义一个方法,方法的参数传递一个字符串和两个Consumer接口,Consumer接口的泛型使用字符串 public static void method(String s, Consumer&lt;String&gt; con1 ,Consumer&lt;String&gt; con2)&#123; //con1.accept(s); //con2.accept(s); //使用andThen方法,把两个Consumer接口连接到一起,在消费数据 con1.andThen(con2).accept(s);//con1连接con2,先执行con1消费数据,在执行con2消费数据 &#125; public static void main(String[] args) &#123; //调用method方法,传递一个字符串,两个Lambda表达式 method(\"Hello\", (t)-&gt;&#123; //消费方式:把字符串转换为大写输出 System.out.println(t.toUpperCase()); &#125;, (t)-&gt;&#123; //消费方式:把字符串转换为小写输出 System.out.println(t.toLowerCase()); &#125;); &#125;&#125; Predicate接口java.util.function.Predicate&lt;T&gt;接口。 作用：对某种类型的数据进行判断，从而得到一个boolean值结果。 抽象方法：testPredicate接口中包含一个抽象方法：boolean test(T t)。 使用 1234567891011121314151617181920public class Demo01Predicate &#123; public static boolean checkString(String s, Predicate&lt;String&gt; pre)&#123; return pre.test(s); &#125; public static void main(String[] args) &#123; //定义一个字符串 String s = \"abcdef\"; //调用checkString方法对字符串进行校验,参数传递字符串和Lambda表达式 /*boolean b = checkString(s,(String str)-&gt;&#123; //对参数传递的字符串进行判断,判断字符串的长度是否大于5,并把判断的结果返回 return str.length()&gt;5; &#125;);*/ //优化Lambda表达式 boolean b = checkString(s,str-&gt;str.length()&gt;5); System.out.println(b); &#125;&#125; 默认方法：and效果相当于逻辑运算符的 &amp;&amp; 使用 123456789101112131415161718192021222324252627public class Demo02Predicate_and &#123; /* 定义一个方法,方法的参数,传递一个字符串 传递两个Predicate接口 一个用于判断字符串的长度是否大于5 一个用于判断字符串中是否包含a 两个条件必须同时满足 */ public static boolean checkString(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; //return pre1.test(s) &amp;&amp; pre2.test(s); return pre1.and(pre2).test(s);//等价于return pre1.test(s) &amp;&amp; pre2.test(s); &#125; public static void main(String[] args) &#123; //定义一个字符串 String s = \"abcdef\"; //调用checkString方法,参数传递字符串和两个Lambda表达式 boolean b = checkString(s,(String str)-&gt;&#123; //判断字符串的长度是否大于5 return str.length()&gt;5; &#125;,(String str)-&gt;&#123; //判断字符串中是否包含a return str.contains(\"a\"); &#125;); System.out.println(b); &#125;&#125; 默认方法：or效果相当于逻辑运算符的 || 使用 123456789101112131415161718192021222324252627public class Demo03Predicate_or &#123; /* 定义一个方法,方法的参数,传递一个字符串 传递两个Predicate接口 一个用于判断字符串的长度是否大于5 一个用于判断字符串中是否包含a 满足一个条件即可 */ public static boolean checkString(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)&#123; //return pre1.test(s) || pre2.test(s); return pre1.or(pre2).test(s);//等价于return pre1.test(s) || pre2.test(s); &#125; public static void main(String[] args) &#123; //定义一个字符串 String s = \"bc\"; //调用checkString方法,参数传递字符串和两个Lambda表达式 boolean b = checkString(s,(String str)-&gt;&#123; //判断字符串的长度是否大于5 return str.length()&gt;5; &#125;,(String str)-&gt;&#123; //判断字符串中是否包含a return str.contains(\"a\"); &#125;); System.out.println(b); &#125;&#125; 默认方法：negate效果相当于逻辑运算符的 ! 使用 123456789101112131415161718192021public class Demo04Predicate_negate &#123; /* 定义一个方法,方法的参数,传递一个字符串 使用Predicate接口判断字符串的长度是否大于5 */ public static boolean checkString(String s, Predicate&lt;String&gt; pre)&#123; //return !pre.test(s); return pre.negate().test(s);//等效于return !pre.test(s); &#125; public static void main(String[] args) &#123; //定义一个字符串 String s = \"abc\"; //调用checkString方法,参数传递字符串和Lambda表达式 boolean b = checkString(s,(String str)-&gt;&#123; //判断字符串的长度是否大于5,并返回结果 return str.length()&gt;5; &#125;); System.out.println(b); &#125;&#125; Function接口java.util.function.Function&lt;T,R&gt;：用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 抽象方法：applyFunction接口中最主要的抽象方法为：R apply(T t)，根据类型T的参数获取类型R的结果。 使用 12345678910111213141516171819202122232425public class Demo01Function &#123; /* 定义一个方法 方法的参数传递一个字符串类型的整数 方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt; 使用Function接口中的方法apply,把字符串类型的整数,转换为Integer类型的整数 */ public static void change(String s, Function&lt;String,Integer&gt; fun)&#123; //Integer in = fun.apply(s); int in = fun.apply(s);//自动拆箱 Integer-&gt;int System.out.println(in); &#125; public static void main(String[] args) &#123; //定义一个字符串类型的整数 String s = \"1234\"; //调用change方法,传递字符串类型的整数,和Lambda表达式 change(s,(String str)-&gt;&#123; //把字符串类型的整数,转换为Integer类型的整数返回 return Integer.parseInt(str); &#125;); //优化Lambda change(s,str-&gt;Integer.parseInt(str)); &#125;&#125; 默认方法：andThen该方法同样用于“先做什么，再做什么”的场景，和Consumer中的andThen差不多。 使用 1234567891011121314151617181920212223242526272829public class Demo02Function_andThen &#123; /* 定义一个方法 参数串一个字符串类型的整数 参数再传递两个Function接口 一个泛型使用Function&lt;String,Integer&gt; 一个泛型使用Function&lt;Integer,String&gt; */ public static void change(String s, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)&#123; String ss = fun1.andThen(fun2).apply(s); System.out.println(ss); &#125; public static void main(String[] args) &#123; //定义一个字符串类型的整数 String s = \"123\"; //调用change方法,传递字符串和两个Lambda表达式 change(s,(String str)-&gt;&#123; //把字符串转换为整数+10 return Integer.parseInt(str)+10; &#125;,(Integer i)-&gt;&#123; //把整数转换为字符串 return i+\"\"; &#125;); //优化Lambda表达式 change(s,str-&gt;Integer.parseInt(str)+10,i-&gt;i+\"\"); &#125;&#125; 注意：Function的前置条件泛型和后置条件泛型可以相同。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记18——网络编程","slug":"Java学习日记18——网络编程","date":"2020-07-19T12:32:14.595Z","updated":"2020-07-19T13:59:12.745Z","comments":true,"path":"2020/07/19/Java学习日记18——网络编程/","link":"","permalink":"http://yoursite.com/2020/07/19/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B018%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"Java学习每一天","text":"Java学习每一天 网络编程入门软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 常用端口号 TCP通信程序TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket(\"127.0.0.1\", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 ServerSocket类ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 简单的TCP网络程序示例TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 代码实现客户端实现： 123456789101112131415161718192021public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号 Socket socket = new Socket(\"127.0.0.1\",8888); //2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //3.使用网络字节输出流OutputStream对象中的方法write,给服务器发送数据 os.write(\"你好服务器\".getBytes()); //4.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //5.使用网络字节输入流InputStream对象中的方法read,读取服务器回写的数据 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); //6.释放资源(Socket) socket.close(); &#125;&#125; 服务端实现： 123456789101112131415161718192021public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建服务器ServerSocket对象和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); //2.使用ServerSocket对象中的方法accept,获取到请求的客户端对象Socket Socket socket = server.accept(); //3.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //4.使用网络字节输入流InputStream对象中的方法read,读取客户端发送的数据 byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); //5.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //6.使用网络字节输出流OutputStream对象中的方法write,给客户端回写数据 os.write(\"收到谢谢\".getBytes()); //7.释放资源(Socket,ServerSocket) socket.close(); server.close(); &#125;&#125; 综合案例文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 基本实现客户端实现： 123456789101112131415161718192021222324252627282930313233343536public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"c:\\\\1.jpg\"); //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 Socket socket = new Socket(\"127.0.0.1\",8888); //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len = 0; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 os.write(bytes,0,len); &#125; /* 解决:上传完文件,给服务器写一个结束标记 void shutdownOutput() 禁用此套接字的输出流。 对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 */ socket.shutdownOutput(); //6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据 while((len = is.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //8.释放资源(FileInputStream,Socket) fis.close(); socket.close(); &#125;&#125; 服务端实现： 123456789101112131415161718192021222324252627282930313233public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个服务器ServerSocket对象,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象 Socket socket = server.accept(); //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //4.判断d:\\\\upload文件夹是否存在,不存在则创建 File file = new File(\"d:\\\\upload\"); if(!file.exists())&#123; file.mkdirs(); &#125; //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(file+\"\\\\1.jpg\"); //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件 int len =0; byte[] bytes = new byte[1024]; while((len = is.read(bytes))!=-1)&#123; //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上 fos.write(bytes,0,len); &#125; //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象 //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写\"上传成功\" socket.getOutputStream().write(\"上传成功\".getBytes()); //10.释放资源(FileOutputStream,Socket,ServerSocket) fos.close(); socket.close(); server.close(); &#125;&#125; 优化优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12//5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地FileOutputStream fos = new FileOutputStream(file+\"\\\\1.jpg\"); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个服务器ServerSocket对象,和系统要指定的端口号 ServerSocket server = new ServerSocket(8888); /* 让服务器一直处于监听状态(死循环accept方法) 有一个客户端上传文件,就保存一个文件 */ while(true)&#123; //2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象 Socket socket = server.accept(); /* 使用多线程技术,提高程序的效率 有一个客户端上传文件,就开启一个线程,完成文件的上传 */ new Thread(new Runnable() &#123; //完成文件的上传 @Override public void run() &#123; try &#123; //3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //4.判断d:\\\\upload文件夹是否存在,不存在则创建 File file = new File(\"d:\\\\upload\"); if(!file.exists())&#123; file.mkdirs(); &#125; /* 自定义一个文件的命名规则:防止同名的文件被覆盖 规则:域名+毫秒值+随机数 */ String fileName = \"itcast\"+System.currentTimeMillis()+new Random().nextInt(999999)+\".jpg\"; //5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地 //FileOutputStream fos = new FileOutputStream(file+\"\\\\1.jpg\"); FileOutputStream fos = new FileOutputStream(file+\"\\\\\"+fileName); //6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件 int len =0; byte[] bytes = new byte[1024]; while((len = is.read(bytes))!=-1)&#123; //7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上 fos.write(bytes,0,len); &#125; //8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象 //9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写\"上传成功\" socket.getOutputStream().write(\"上传成功\".getBytes()); //10.释放资源(FileOutputStream,Socket,ServerSocket) fos.close(); socket.close(); &#125;catch (IOException e)&#123; System.out.println(e); &#125; &#125; &#125;).start(); &#125; //服务器就不用关闭 //server.close(); &#125;&#125; 模拟B\\S服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 案例实现服务端实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TCPServerThread &#123; public static void main(String[] args) throws IOException &#123; //创建一个服务器ServerSocket,和系统要指定的端口号 ServerSocket server = new ServerSocket(8080); /* 浏览器解析服务器回写的html页面,页面中如果有图片,那么浏览器就会单独的开启一个线程,读取服务器的图片 我们就的让服务器一直处于监听状态,客户端请求一次,服务器就回写一次 */ while(true)&#123; //使用accept方法获取到请求的客户端对象(浏览器) Socket socket = server.accept(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象 InputStream is = socket.getInputStream(); //使用网络字节输入流InputStream对象中的方法read读取客户端的请求信息 /*byte[] bytes = new byte[1024]; int len = 0; while((len = is.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125;*/ //把is网络字节输入流对象,转换为字符缓冲输入流 BufferedReader br = new BufferedReader(new InputStreamReader(is)); //把客户端请求信息的第一行读取出来 GET /11_Net/web/index.html HTTP/1.1 String line = br.readLine(); System.out.println(line); //把读取的信息进行切割,只要中间部分 /11_Net/web/index.html String[] arr = line.split(\" \"); //把路径前边的/去掉,进行截取 11_Net/web/index.html String htmlpath = arr[1].substring(1); //创建一个本地字节输入流,构造方法中绑定要读取的html路径 FileInputStream fis = new FileInputStream(htmlpath); //使用Socket中的方法getOutputStream获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 os.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes()); os.write(\"Content-Type:text/html\\r\\n\".getBytes()); // 必须要写入空行,否则浏览器不解析 os.write(\"\\r\\n\".getBytes()); //一读一写复制文件,把服务读取的html文件回写到客户端 int len = 0; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; os.write(bytes,0,len); &#125; //释放资源 fis.close(); socket.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //server.close(); &#125;&#125; 核心：","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记17——缓冲流、转换流、序列化流、打印流","slug":"Java学习日记17——缓冲流、转换流、序列化流、打印流","date":"2020-07-19T07:42:03.935Z","updated":"2020-07-19T14:02:06.191Z","comments":true,"path":"2020/07/19/Java学习日记17——缓冲流、转换流、序列化流、打印流/","link":"","permalink":"http://yoursite.com/2020/07/19/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B017%E2%80%94%E2%80%94%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81/","excerpt":"Java学习每一天","text":"Java学习每一天 缓冲流缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); 输入流使用步骤: 创建FileInputStream对象,构造方法中绑定要读取的数据源 创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 使用BufferedInputStream对象中的方法read,读取文件 释放资源 123456789101112131415161718192021222324public class Demo02BufferedInputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 BufferedInputStream bis = new BufferedInputStream(fis); //3.使用BufferedInputStream对象中的方法read,读取文件 //int read()从输入流中读取数据的下一个字节。 /*int len = 0;//记录每次读取到的字节 while((len = bis.read())!=-1)&#123; System.out.println(len); &#125;*/ //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes =new byte[1024];//存储每次读取的数据 int len = 0; //记录每次读取的有效字节个数 while((len = bis.read(bytes))!=-1)&#123; System.out.println(new String(bytes,0,len)); &#125; //4.释放资源 bis.close(); &#125;&#125; 输出流使用步骤： 创建FileOutputStream对象,构造方法中绑定要输出的目的地 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 释放资源(会先调用flush方法刷新数据,第4部可以省略) 1234567891011121314public class Demo01BufferedOutputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 BufferedOutputStream bos = new BufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 bos.write(\"我把数据写入到内部缓冲区中\".getBytes()); //4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 bos.flush(); //5.释放资源(会先调用flush方法刷新数据,第4部可以省略) bos.close(); &#125;&#125; 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 输入流使用步骤: 创建字符缓冲输入流对象,构造方法中传递字符输入流 使用字符缓冲输入流对象中的方法read/readLine读取文本 释放资源 1234567891011121314151617181920212223242526272829303132public class Demo04BufferedReader &#123; public static void main(String[] args) throws IOException &#123; //1.创建字符缓冲输入流对象,构造方法中传递字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\c.txt\")); //2.使用字符缓冲输入流对象中的方法read/readLine读取文本 /*String line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line);*/ /* 发下以上读取是一个重复的过程,所以可以使用循环优化 不知道文件中有多少行数据,所以使用while循环 while的结束条件,读取到null结束 */ String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; //3.释放资源 br.close(); &#125;&#125; 输出流使用步骤: 创建字符缓冲输出流对象,构造方法中传递字符输出流 调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 释放资源 1234567891011121314151617public class Demo03BufferedWriter &#123; public static void main(String[] args) throws IOException &#123; //System.out.println(); //1.创建字符缓冲输出流对象,构造方法中传递字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\c.txt\")); //2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 for (int i = 0; i &lt;10 ; i++) &#123; bw.write(\"传智播客\"); //bw.write(\"\\r\\n\"); bw.newLine(); &#125; //3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 bw.flush(); //4.释放资源 bw.close(); &#125;&#125; 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 实现： 12345678910111213141516171819202122232425262728293031public class Demo05Test &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); //2.创建字符缓冲输入流对象,构造方法中绑定字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\in.txt\")); //3.创建字符缓冲输出流对象,构造方法中绑定字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\out.txt\")); //4.使用字符缓冲输入流中的方法readline,逐行读取文本 String line; while((line = br.readLine())!=null)&#123; //5.对读取到的文本进行切割,获取行中的序号和文本内容 String[] arr = line.split(\"\\\\.\"); //6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..) map.put(arr[0],arr[1]); &#125; //7.遍历HashMap集合,获取每一个键值对 for(String key : map.keySet())&#123; String value = map.get(key); //8.把每一个键值对,拼接为一个文本行 line = key + \".\" + value; //9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中 bw.write(line); bw.newLine();//写换行 &#125; //10.释放资源 bw.close(); br.close(); &#125;&#125; 转换流按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\"); 指定编码读取1234567891011121314151617181920212223public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = \"E:\\\\file_gbk.txt\"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\"); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = \"E:\\\\out.txt\"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(\"你好\"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = \"E:\\\\out2.txt\"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\"); // 写出数据 osw2.write(\"你好\");// 保存为4个字节 osw2.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 12345678910111213141516171819202122232425public class TransDemo &#123; public static void main(String[] args) &#123; // 1.定义文件路径 String srcFile = \"file_gbk.txt\"; String destFile = \"file_utf8.txt\"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); &#125;&#125; 序列化Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream(\"employee.txt\");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678910111213141516171819202122232425262728293031323334353637383940public class Person implements Serializable&#123; // 加入序列版号 private static final long serialVersionUID = 1L; private String name; //private static int age; private transient int age; //public int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 使用步骤: 创建ObjectOutputStream对象,构造方法中传递字节输出流 使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中 释放资源 12345678910public class Demo01ObjectOutputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建ObjectOutputStream对象,构造方法中传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"10_IO\\\\person.txt\")); //2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中 oos.writeObject(new Person(\"小美女\",18)); //3.释放资源 oos.close(); &#125;&#125; ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1使用步骤: 创建ObjectInputStream对象,构造方法中传递字节输入流 使用ObjectInputStream对象中的方法readObject读取保存对象的文件 释放资源 使用读取出来的对象(打印) 1234567891011121314public class Demo02ObjectInputStream &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.创建ObjectInputStream对象,构造方法中传递字节输入流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10_IO\\\\person.txt\")); //2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件 Object o = ois.readObject(); //3.释放资源 ois.close(); //4.使用读取出来的对象(打印) System.out.println(o); Person p = (Person)o; System.out.println(p.getName()+p.getAge()); &#125;&#125; 注意：当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 123456789101112131415161718192021222324252627public class Demo03Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //1.定义一个存储Person对象的ArrayList集合 ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); //2.往ArrayList集合中存储Person对象 list.add(new Person(\"张三\",18)); list.add(new Person(\"李四\",19)); list.add(new Person(\"王五\",20)); //3.创建一个序列化流ObjectOutputStream对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"10_IO\\\\list.txt\")); //4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化 oos.writeObject(list); //5.创建一个反序列化ObjectInputStream对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"10_IO\\\\list.txt\")); //6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合 Object o = ois.readObject(); //7.把Object类型的集合转换为ArrayList类型 ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o; //8.遍历ArrayList集合 for (Person p : list2) &#123; System.out.println(p); &#125; //9.释放资源 ois.close(); oos.close(); &#125;&#125; 打印流平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream(\"ps.txt\")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以改变它的流向。 1234567891011public class Demo02PrintStream &#123; public static void main(String[] args) throws FileNotFoundException &#123; System.out.println(\"我是在控制台输出\"); PrintStream ps = new PrintStream(\"10_IO\\\\目的地是打印流.txt\"); System.setOut(ps);//把输出语句的目的地改变为打印流的目的地 System.out.println(\"我在打印流的目的地中输出\"); ps.close(); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记16——字节流、字符流","slug":"Java学习日记16——字节流、字符流","date":"2020-07-18T11:27:42.673Z","updated":"2020-07-18T12:54:44.633Z","comments":true,"path":"2020/07/18/Java学习日记16——字节流、字符流/","link":"","permalink":"http://yoursite.com/2020/07/18/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B016%E2%80%94%E2%80%94%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81/","excerpt":"Java学习每一天","text":"Java学习每一天 字节流字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类是OutputStream的子类。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"b.txt\"); &#125;&#125; 写出字节数据 使用步骤：` 创建一个FileOutputStream对象,构造方法中传递写入数据的目的地 调用FileOutputStream对象中的方法write,把数据写入到文件中 释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率) 1234567891011public class Demo01OutputStream &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个FileOutputStream对象,构造方法中传递写入数据的目的地 FileOutputStream fos = new FileOutputStream(\"09_IOAndProperties\\\\a.txt\"); //2.调用FileOutputStream对象中的方法write,把数据写入到文件中 //public abstract void write(int b) ：将指定的字节输出流。 fos.write(97); //3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率) fos.close(); &#125;&#125; 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"黑马程序员\".getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：黑马程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\"); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写 public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\", true); // 字符串转换为字节数组 byte[] b = \"abcde\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\\r\\n 。 代码使用演示： 123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\"fos.txt\", true); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\"\\r\\n\".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n； Unix系统里，每行结尾只有 换行 ，即\\n； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(\"b.txt\"); &#125;&#125; 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1。 创建FileInputStream对象,构造方法中绑定要读取的数据源 使用FileInputStream对象中的方法read,读取文件 释放资源 代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 练习：图片复制复制原理图解 案例实现复制图片文件，代码使用演示： 123456789101112131415161718192021222324public class Copy &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len); &#125; // 3.关闭资源 fos.close(); fis.close(); &#125;&#125; 小贴士： 流的关闭原则：先开后关，后开先关。 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\"b.txt\"); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1， 代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员序 获取有效的字符改进，代码使用演示： 123456789101112131415161718192021public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(\"a.txt\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"b.txt\"); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(97); // 写出第1个字符 fw.write('b'); // 写出第2个字符 fw.write('C'); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串转换为字节数组 char[] chars = \"黑马程序员\".toCharArray(); // 写出字符数组 fw.write(chars); // 黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\"fw.txt\"); // 字符串 String msg = \"黑马程序员\"; // 写出字符数组 fw.write(msg); //黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(\"fw.txt\"，true); // 写出字符串 fw.write(\"黑马\"); // 写出换行 fw.write(\"\\r\\n\"); // 写出字符串 fw.write(\"程序员\"); // 关闭资源 fw.close(); &#125;&#125;输出结果:黑马程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(\"黑马程序员\"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011public class HandleException2 &#123; public static void main(String[] args) &#123; // 创建流对象 try ( FileWriter fw = new FileWriter(\"fw.txt\"); ) &#123; // 写出数据 fw.write(\"黑马程序员\"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK9的改进JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close。 格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 改进后，代码使用演示： 12345678910111213141516171819public class TryDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 final FileReader fr = new FileReader(\"in.txt\"); FileWriter fw = new FileWriter(\"out.txt\"); // 引入到try中 try (fr; fw) &#123; // 定义变量 int b; // 读取数据 while ((b = fr.read())!=-1) &#123; // 写出数据 fw.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 属性集java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(\"filename\", \"a.txt\"); properties.setProperty(\"length\", \"209385038\"); properties.setProperty(\"location\", \"D:\\\\a.txt\"); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(\"filename\")); System.out.println(properties.getProperty(\"length\")); System.out.println(properties.getProperty(\"location\")); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+\" -- \"+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 与流相关的方法 store方法：把集合中的临时数据,持久化写入到硬盘中存储 `void store(OutputStream out, String comments)` ` void store(Writer writer, String comments)`参数: OutputStream out:字节输出流,不能写入中文 Writer writer:字符输出流,可以写中文 String comments:注释,用来解释说明保存的文件是做什么用的 不能使用中文,会产生乱码,默认是Unicode编码 一般使用&quot;&quot;空字符串 使用步骤: 创建Properties集合对象,添加数据 创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 释放资源 123456789101112131415161718private static void show02() throws IOException &#123; //1.创建Properties集合对象,添加数据 Properties prop = new Properties(); prop.setProperty(\"赵丽颖\",\"168\"); prop.setProperty(\"迪丽热巴\",\"165\"); prop.setProperty(\"古力娜扎\",\"160\"); //2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 //FileWriter fw = new FileWriter(\"09_IOAndProperties\\\\prop.txt\"); //3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 //prop.store(fw,\"save data\"); //4.释放资源 //fw.close(); prop.store(new FileOutputStream(\"09_IOAndProperties\\\\prop2.txt\"),\"\"); &#125; load方法：把硬盘中保存的文件(键值对)，读取到集合中使用 ​ void load(InputStream inStream)​ void load(Reader reader) ​ 参数:​ InputStream inStream:字节输入流,不能读取含有中文的键值对​ Reader reader:字符输入流,能读取含有中文的键值对 使用步骤: 创建Properties集合对象 使用Properties集合对象中的方法load读取保存键值对的文件 遍历Properties集合 12345678910111213private static void show03() throws IOException &#123; //1.创建Properties集合对象 Properties prop = new Properties(); //2.使用Properties集合对象中的方法load读取保存键值对的文件 prop.load(new FileReader(\"09_IOAndProperties\\\\prop.txt\")); //prop.load(new FileInputStream(\"09_IOAndProperties\\\\prop.txt\")); //3.遍历Properties集合 Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) &#123; String value = prop.getProperty(key); System.out.println(key+\"=\"+value); &#125; &#125; 注意: 存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号) 存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取 存储键值对的文件中,键与值默认都是字符串,不用再加引号","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记15——File类、递归","slug":"Java学习日记15——File类、递归","date":"2020-07-15T12:13:00.368Z","updated":"2020-07-15T13:44:48.407Z","comments":true,"path":"2020/07/15/Java学习日记15——File类、递归/","link":"","permalink":"http://yoursite.com/2020/07/15/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B015%E2%80%94%E2%80%94File%E7%B1%BB%E3%80%81%E9%80%92%E5%BD%92/","excerpt":"Java学习每一天","text":"Java学习每一天 File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 获取分隔符static String pathSeparator ：与系统有关的路径分隔符，为了方便，它被表示为一个字符串。 static char pathSeparatorChar ：与系统有关的路径分隔符。 static String separator ：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 static char separatorChar：与系统有关的默认名称分隔符。 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314151617// 文件路径名String pathname = \"D:\\\\aaa.txt\";File file1 = new File(pathname); // 文件路径名String pathname2 = \"D:\\\\aaa\\\\bbb.txt\";File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = \"d:\\\\aaa\"; String child = \"bbb.txt\"; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(\"d:\\\\aaa\");String child = \"bbb.txt\";File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 路径是不区分大小写。 路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠。 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 1234567891011121314151617181920212223242526272829303132public class FileGet &#123; public static void main(String[] args) &#123; File f = new File(\"d:/aaa/bbb.java\"); // 一定是绝对路径 System.out.println(\"文件绝对路径:\"+f.getAbsolutePath()); // 相当于toString方法 System.out.println(\"文件构造路径:\"+f.getPath()); // 获取最后的文件名或文件夹名 System.out.println(\"文件名称:\"+f.getName()); // 获取文件大小，文件夹没有大小概念 System.out.println(\"文件长度:\"+f.length()+\"字节\"); File f2 = new File(\"d:/aaa\"); System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath()); System.out.println(\"目录构造路径:\"+f2.getPath()); System.out.println(\"目录名称:\"+f2.getName()); System.out.println(\"目录长度:\"+f2.length()); &#125;&#125;输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(\"d:\\\\aaa\\\\bbb.java\"); File f2 = new File(\"d:\\\\aaa\"); // 判断是否存在 System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists()); System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists()); // 判断是文件还是目录 System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile()); System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory()); &#125;&#125;输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 12345678910111213141516171819202122232425262728293031public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 // 如果路径不存在，则会报异常 File f = new File(\"aaa.txt\"); System.out.println(\"是否存在:\"+f.exists()); // false System.out.println(\"是否创建:\"+f.createNewFile()); // true System.out.println(\"是否存在:\"+f.exists()); // true // 目录的创建 // 只能创建一级目录 File f2= new File(\"newDir\"); System.out.println(\"是否存在:\"+f2.exists());// false System.out.println(\"是否创建:\"+f2.mkdir()); // true System.out.println(\"是否存在:\"+f2.exists());// true // 创建多级目录 // 既可以创建多级，又可以创建多级 File f3= new File(\"newDira\\\\newDirb\"); System.out.println(f3.mkdir());// false File f4= new File(\"newDira\\\\newDirb\"); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; 注意：delete方法，如果此File表示目录，则目录必须为空才能删除。 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(\"d:\\\\java_code\"); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 递归指在当前方法内调用自己的这种现象。 概述递归的分类: 直接递归：称为方法自身调用自己。 间接递归：A方法调用B方法，B方法调用C方法，C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 构造方法,禁止递归 示例 计算1 ~ n的和 123456789101112131415161718192021222324252627282930/* 定义一个方法,使用递归计算1-n之间的和 1+2+3+...+n n+(n-1)+(n-2)+...+1 已知: 最大值:n 最小值:1 使用递归必须明确: 1.递归的结束条件 获取到1的时候结束 2.递归的目的 获取下一个被加的数字(n-1) */public class DiGuiDemo &#123; public static void main(String[] args) &#123; int num = 5; int sum = getSum(num); System.out.println(sum); &#125; public static int getSum(int num) &#123; //获取到1的时候结束 if(num == 1)&#123; return 1; &#125; //获取下一个被加的数字(n-1) return num + getSum(num-1); &#125;&#125; 代码执行图解 小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。 过滤器用ListFiles方法的两个重载调用过滤器来过了不需要的数据。 File[] listFiles(FileFilter filter) File[] listFiles(FilenameFilter filter) 这两个重载的参数都是过滤器，分别是FileFilter接口和FilenameFilter接口，这两个接口都没有实现类，需要自己写实现类，并重写accept方法。 两个过滤器的accept方法参数不同。 FileFilter 的： boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 ​ 参数:​ File pathname：使用ListFiles方法遍历目录,得到的每一个文件对象 FilenameFilter 的： boolean accept(File dir, String name)测试指定文件是否应该包含在某一文件列表中 ​ 参数:​ File dir：构造方法中传递的被遍历的目录​ String name：使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称 示例 12345678910111213141516171819202122232425// 搜索文件public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File(\"D:\\\\aaa\"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(\".java\")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; Lambda优化 1234567891011121314public static void printDir3(File dir) &#123; // lambda的改写 // 省略了()、&#123;&#125;、return、分号、参数类型 File[] files = dir.listFiles(f-&gt;f.getName().endsWith(\".java\") || f.isDirectory()); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println(\"文件名:\" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记14——线程池、Lambda表达式","slug":"Java学习日记14——线程池、Lambda表达式","date":"2020-07-15T04:57:45.292Z","updated":"2020-07-15T06:19:51.665Z","comments":true,"path":"2020/07/15/Java学习日记14——线程池、Lambda表达式/","link":"","permalink":"http://yoursite.com/2020/07/15/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B014%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"Java学习每一天","text":"Java学习每一天 等待唤醒机制线程间通信多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 等待唤醒机制在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 注意： wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 等待唤醒机制示例等待唤醒机制其实就是经典的“生产者与消费者”的问题。 代码演示： 包子资源类： 123456789public class BaoZi &#123; //皮 String pi; //陷 String xian; //包子的状态: 有 true,没有 false,设置初始值为false没有包子 boolean flag = false;&#125; 吃货线程类： 1234567891011121314151617181920212223242526272829303132333435363738public class ChiHuo extends Thread&#123; //1.需要在成员位置创建一个包子变量 private BaoZi bz; //2.使用带参数构造方法,为这个包子变量赋值 public ChiHuo(BaoZi bz) &#123; this.bz = bz; &#125; //设置线程任务(run):吃包子 @Override public void run() &#123; //使用死循环,让吃货一直吃包子 while (true)&#123; //必须同时同步技术保证两个线程只能有一个在执行 synchronized (bz)&#123; //对包子的状态进行判断 if(bz.flag==false)&#123; //吃货调用wait方法进入等待状态 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //被唤醒之后执行的代码,吃包子 System.out.println(\"吃货正在吃:\"+bz.pi+bz.xian+\"的包子\"); //吃货吃完包子 //修改包子的状态为false没有 bz.flag = false; //吃货唤醒包子铺线程,生产包子 bz.notify(); System.out.println(\"吃货已经把:\"+bz.pi+bz.xian+\"的包子吃完了,包子铺开始生产包子\"); System.out.println(\"----------------------------------------------------\"); &#125; &#125; &#125;&#125; 包子铺线程类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BaoZiPu extends Thread&#123; //1.需要在成员位置创建一个包子变量 private BaoZi bz; //2.使用带参数构造方法,为这个包子变量赋值 public BaoZiPu(BaoZi bz) &#123; this.bz = bz; &#125; //设置线程任务(run):生产包子 @Override public void run() &#123; //定义一个变量 int count = 0; //让包子铺一直生产包子 while(true)&#123; //必须同时同步技术保证两个线程只能有一个在执行 synchronized (bz)&#123; //对包子的状态进行判断 if(bz.flag==true)&#123; //包子铺调用wait方法进入等待状态 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //被唤醒之后执行,包子铺生产包子 //增加一些趣味性:交替生产两种包子 if(count%2==0)&#123; //生产 薄皮三鲜馅包子 bz.pi = \"薄皮\"; bz.xian = \"三鲜馅\"; &#125;else&#123; //生产 冰皮 牛肉大葱陷 bz.pi = \"冰皮\"; bz.xian = \"牛肉大葱陷\"; &#125; count++; System.out.println(\"包子铺正在生产:\"+bz.pi+bz.xian+\"包子\"); //生产包子需要3秒钟 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //包子铺生产好了包子 //修改包子的状态为true有 bz.flag = true; //唤醒吃货线程,让吃货线程吃包子 bz.notify(); System.out.println(\"包子铺已经生产好了:\"+bz.pi+bz.xian+\"包子,吃货可以开始吃了\"); &#125; &#125; &#125;&#125; 测试类： 12345678910public class Demo &#123; public static void main(String[] args) &#123; //创建包子对象; BaoZi bz =new BaoZi(); //创建包子铺线程,开启,生产包子; new BaoZiPu(bz).start(); //创建吃货线程,开启,吃包子; new ChiHuo(bz).start(); &#125;&#125; 执行效果： 1234567891011包子铺正在生产:薄皮三鲜馅包子包子铺已经生产好了:薄皮三鲜馅包子,吃货可以开始吃了吃货正在吃:薄皮三鲜馅的包子吃货已经把:薄皮三鲜馅的包子吃完了,包子铺开始生产包子----------------------------------------------------包子铺正在生产:冰皮牛肉大葱陷包子包子铺已经生产好了:冰皮牛肉大葱陷包子,吃货可以开始吃了吃货正在吃:冰皮牛肉大葱陷的包子吃货已经把:冰皮牛肉大葱陷的包子吃完了,包子铺开始生产包子----------------------------------------------------包子铺正在生产:薄皮三鲜馅包子 线程池如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 线程池的使用步骤： 使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类,实现Runnable接口,重写run方法,设置线程任务 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 调用ExecutorService中的方法shutdown销毁线程池(不建议执行) 示例： Runnable实现类： 123456public class RunnableImpl implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"创建了一个新的线程执行\"); &#125;&#125; 线程池测试类： 1234567891011121314151617public class Demo01ThreadPool &#123; public static void main(String[] args) &#123; //1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 ExecutorService es = Executors.newFixedThreadPool(2); //3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 es.submit(new RunnableImpl());//pool-1-thread-1创建了一个新的线程执行 //线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用 es.submit(new RunnableImpl());//pool-1-thread-1创建了一个新的线程执行 es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程执行 //4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行) es.shutdown(); es.submit(new RunnableImpl());//抛异常,线程池都没有了,就不能获取线程了 &#125;&#125; Lambda表达式面向对象的思想: ​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式编程思想: ​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程 2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性。 格式1(参数列表) -&gt; &#123;一些重写方法的代码&#125;; 格式说明： ()：接口中抽象方法的参数列表，没有参数，就空着；有参数就写出参数,，个参数使用逗号分隔 -&gt;：传递的意思，把参数传递给方法体{} {}：重写接口的抽象方法的方法体 示例给定一个厨子Cook接口 1234public interface Cook &#123; //定义无参数无返回值的方法makeFood public abstract void makeFood();&#125; 使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 123456789101112131415161718public static void main(String[] args) &#123; // 普通写法 invokeCook(new Cook() &#123; @Override public void makeFood() &#123; System.out.println(\"吃饭了\"); &#125; &#125;); // Lambda写法 invokeCook(() -&gt; &#123; System.out.println(\"吃饭啦！\"); &#125;); //定义一个方法，调用Cook接口中的方法makeFood public static void invokeCook(Cook cook)&#123; cook.makeFood(); &#125;&#125; Lambda省略格式省略规则 在Lambda标准格式的基础上，使用省略写法的规则为： (参数列表):括号中参数列表的数据类型,可以省略不写 (参数列表):括号中的参数如果只有一个,那么类型和()都可以省略 {一些代码}:如果{}中的代码只有一行,无论是否有返回值,都可以省略({},return,分号) 注意：要省略{},return,分号必须一起省略3.11 练习：使用Lambda省略格式 示例： 对上面的Lambda写法省略。 1invokeCook(() -&gt; System.out.println(\"吃饭啦！\")); Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记13——线程、同步","slug":"Java学习日记13——线程、同步","date":"2020-07-14T11:54:30.055Z","updated":"2020-07-14T15:28:52.600Z","comments":true,"path":"2020/07/14/Java学习日记13——线程、同步/","link":"","permalink":"http://yoursite.com/2020/07/14/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B013%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5/","excerpt":"Java学习每一天","text":"Java学习每一天 线程多线程原理通过下面例子解释多线程原理。 自定义线程类： 1234567891011121314public class MyThread extends Thread&#123; // 利用构造方法设置线程名 public MyThread(String name)&#123; super(name); &#125; // 重写run方法 public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; //getName()方法 来自父亲 System.out.println(getName()+i); &#125; &#125;&#125; 测试类： 12345678910public class Demo &#123; public static void main(String[] args) &#123; System.out.println(\"这里是main线程\"); MyThread mt = new MyThread(\"小强\"); mt.start();//开启了一个新的线程 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"旺财:\"+i); &#125; &#125;&#125; 流程图： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。+ 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 Thread类构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法getName方法public String getName() 作用：获取当前线程名称。 用法：重写run方法的时候可以直接使用，还可以先获取当前线程，用线程调用。 12345678910111213141516171819// 定义一个Thread类的子类public class MyThread extends Thread&#123; //重写Thread类中的run方法,设置线程任务 @Override public void run() &#123; //获取线程名称 //String name = getName(); //System.out.println(name); //Thread t = Thread.currentThread(); //System.out.println(t);//Thread[Thread-0,5,main] //String name = t.getName(); //System.out.println(name); //链式编程 // static Thread currentThread() 返回对当前正在执行的线程对象的引用。 System.out.println(Thread.currentThread().getName()); &#125;&#125; setName方法void setName(String name) 作用：改变线程名称，使之与参数 name 相同。 用法：Thread类子类对象直接调用。 12345678public class Demo01SetThreadName &#123; public static void main(String[] args) &#123; //开启多线程 MyThread mt = new MyThread(); mt.setName(\"小强\"); mt.start(); &#125;&#125; 改变名字法二：创建一个带参数的构造方法，参数传递线程的名称;调用父类的带参构造方法，把线程名称传递给父类，让父类(Thread)给子线程起一个名字 12345678910111213141516public class MyThread extends Thread&#123; // 空参构造 public MyThread()&#123;&#125; // 含参构造 public MyThread(String name)&#123; super(name);//把线程名称传递给父类,让父类(Thread)给子线程起一个名字 &#125; // 重写run方法 @Override public void run() &#123; //获取线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125; sleep方法public static void sleep(long millis) 作用：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行 用法：Thread类的静态方法，直接由Thread类调用。 123456789101112131415public class Demo01Sleep &#123; public static void main(String[] args) &#123; //模拟秒表 for (int i = 1; i &lt;=60 ; i++) &#123; System.out.println(i); //使用Thread类的sleep方法让程序睡眠1秒钟 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 创建线程方式二实现Runnable接口 实现步骤: 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法 示例： 12345678910//1.创建一个Runnable接口的实现类public class RunnableImpl implements Runnable&#123; //2.在实现类中重写Runnable接口的run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+i); &#125; &#125;&#125; 1234567891011121314public class Demo01Runnable &#123; public static void main(String[] args) &#123; //3.创建一个Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t = new Thread(run); //打印线程名称 //5.调用Thread类中的start方法,开启新的线程执行run方法 t.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+i); &#125; &#125;&#125; 实现Runnable接口创建多线程程序的好处: 避免了单继承的局限性一个类只能继承一个类(一个人只能有一个亲爹)，类继承了Thread类就不能继承其他的类 实现了Runnable接口,还可以继承其他的类，实现其他的接口 增强了程序的扩展性,降低了程序的耦合性(解耦)实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦) 实现类中,重写了run方法，用来设置线程任务 创建Thread类对象,调用start方法:用来开启新线程 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 创建线程方式三匿名内部类 格式： 123new 父类/接口()&#123; 重复父类/接口中的方法 &#125;; 示例： 123456789101112131415161718192021222324252627282930313233343536373839public class Demo01InnerClassThread &#123; public static void main(String[] args) &#123; //线程的父类是Thread // new MyThread().start(); new Thread()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+\"黑马\"); &#125; &#125; &#125;.start(); //线程的接口Runnable //Runnable r = new RunnableImpl();//多态 Runnable r = new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+\"程序员\"); &#125; &#125; &#125;; new Thread(r).start(); //简化接口的方式 new Thread(new Runnable()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+\"传智播客\"); &#125; &#125; &#125;).start(); &#125;&#125; 线程安全先举一个例子： 创建3个线程,同时开启,对共享的票进行出售（100张票） 结果中有一部分这样现象： 发现程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 原因：因为cpu的来回切换，可能在一个线程执行了部分代码后，就跳去执行其他线程。 线程同步保证一定区域的代码执行完毕后才会跳转到其他线程。 同步代码块同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 示例： 12345678910111213141516171819202122232425262728293031public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //创建一个锁对象 Object obj = new Object(); //设置线程任务:卖票 @Override public void run() &#123; //使用死循环,让卖票操作重复执行 while(true)&#123; //同步代码块 synchronized (obj)&#123; //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125; &#125; &#125;&#125; 同步方法同步方法:使用synchronized修饰的方法，就叫做同步方，,保证A线程执行该方法的时候，其他线程只能在方法外等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 同步锁是谁? ​ 对于非static方法,同步锁就是this。 ​ 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 12345678910111213141516171819202122232425262728293031public class Ticket implements Runnable&#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; sellTicket(); &#125; &#125; // 定义一个同步方法 public synchronized void sellTicket()&#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+\"正在卖:\"+ticket--); &#125; &#125;&#125; Lock锁Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 使用步骤: 在成员位置创建一个ReentrantLock对象 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 使用如下： 123456789101112131415161718192021222324252627282930313233public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket = 100; //1.在成员位置创建一个ReentrantLock对象 Lock l = new ReentrantLock(); //设置线程任务:卖票 @Override public void run() &#123; //使用死循环,让卖票操作重复执行 while(true)&#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 l.lock(); //先判断票是否存在 if(ticket&gt;0)&#123; //提高安全问题出现的概率,让程序睡眠 try &#123; Thread.sleep(10); //票存在,卖票 ticket-- System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 l.unlock();//无论程序是否异常,都会把锁释放 &#125; &#125; &#125; &#125;&#125; 线程状态线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 Timed Waiting（计时等待）Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)。 小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。 Timed Waiting 线程状态图： BLOCKED（锁阻塞）Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态。 Blocked 线程状态图 Waiting（无限等待）Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 我们通过一段代码来学习一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class WaitingTest &#123; public static Object obj = new Object(); public static void main(String[] args) &#123; // 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123; System.out.println( Thread.currentThread().getName() +\"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象\"); obj.wait(); //无限等待 //obj.wait(5000); //计时等待, 5秒 时间到，自动醒来 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( Thread.currentThread().getName() + \"=== 从waiting状态醒来，获取到锁对象，继续执行了\"); &#125; &#125; &#125; &#125;,\"等待线程\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123;// while (true)&#123; //每隔3秒 唤醒一次 try &#123; System.out.println( Thread.currentThread().getName() +\"----- 等待3秒钟\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; System.out.println( Thread.currentThread().getName() +\"----- 获取到锁对象,调用notify方法，释放锁对象\"); obj.notify(); &#125; &#125;// &#125; &#125;,\"唤醒线程\").start(); &#125;&#125; 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 Waiting 线程状态图 补充知识点到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图： 一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记12——异常、线程","slug":"Java学习日记12——异常、线程","date":"2020-07-13T11:02:20.205Z","updated":"2020-07-13T13:34:21.175Z","comments":true,"path":"2020/07/13/Java学习日记12——异常、线程/","link":"","permalink":"http://yoursite.com/2020/07/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B012%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/","excerpt":"Java学习每一天","text":"Java学习每一天 异常异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 12345678910111213141516171819public class Demo02Exception &#123; public static void main(String[] args) &#123; //创建int类型的数组,并赋值 int[] arr = &#123;1,2,3&#125;; int e = getElement(arr,3); System.out.println(e); &#125; /* 定义一个方法,获取数组指定索引处的元素 参数: int[] arr int index */ public static int getElement(int[] arr,int index)&#123; int ele = arr[index]; return ele; &#125;&#125; 上述程序执行过程图解： 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throwthrow用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 注意: throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象,我们就必须处理这个异常对象 ​ throw关键字后边创建的是RuntimeException或者是 RuntimeException的子类对象,我们可以不处理, 默认交给JVM处理(打印异常对象,中断程序) ​ throw关键字后边创建的是编译异常(写代码的时候报错)，我们就必须处理这个异常，要么throws，要 么try…catch 示例： 1234567891011121314151617181920212223public class ThrowDemo &#123; public static void main(String[] args) &#123; //根据索引找对应的元素 int index = 4; int element = getElement(index); System.out.println(element); &#125; // 返回索引对应地元素 public static int getElement(int index)&#123; //创建一个数组 int[] arr = &#123;2, 4, 52, 2&#125;; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; // ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理 throw new ArrayIndexOutOfBoundsException(\"越界异常\"); &#125; int element = arr[index]; return element; &#125;&#125; Objects非空判断public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 用这个方法可以用来判断空指针异常，不需要我们自己写代码判断空指针。 12345678public static void method(Object obj)&#123; //对传递过来的参数进行合法性判断,判断是否为null /*if(obj == null)&#123; throw new NullPointerException(\"传递的对象的值是null\"); &#125;*/ //Objects.requireNonNull(obj); Objects.requireNonNull(obj,\"传递的对象的值是null\"); 声明异常throws声明异常：如果方法内通过throw抛出了编译时异常(写代码的时候报错)，我们就必须处理这个异常，要么throws，要么try…catch 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 示例 若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 1234567891011121314151617public class ThrowsDemo2 &#123; // main方法再次抛出，交给Jvm处理 public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; // FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常 public static void read(String path)throws FileNotFoundException, IOException &#123; //如果不是 a.txt这个文件，则抛出异常 if (!path.equals(\"a.txt\")) &#123; throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 捕获异常try…catch捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 格式： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意：try和catch都不能单独使用,必须连用。 示例： 1234567891011121314151617181920public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123; // 可能出现异常的代码 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123; //try中抛出的是什么异常，在括号中就定义什么异常类型 // 打印异常 System.out.println(e); &#125; System.out.println(\"over\"); &#125; public static void read(String path) throws FileNotFoundException &#123; //如果不是 a.txt这个文件，则抛出异常 if (!path.equals(\"a.txt\")) &#123; throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块在finally代码块中存放的代码无论异常是否发生，都是一定会被执行的。 注意: finally不能单独使用,必须和try一起使用 finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO) 格式： 123456789101112try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,异常异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch(异常类名 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 示例： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 多个异常使用捕获3种处理方法 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Demo01Exception &#123; public static void main(String[] args) &#123; //1. 多个异常分别处理。 try &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125; try&#123; List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125; //2. 多个异常一次捕获，多次处理。 try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125; /* 一个try多个catch注意事项: catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错 ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException */ /*try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125;*/ //3. 多个异常一次捕获一次处理。 try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (Exception e)&#123; System.out.println(e); &#125; 注意： 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 自定义异常java提供的异常类,不够我们使用,需要自己定义一些异常类 格式： 12345// 继承于Exception或RuntimeExceptionpublic class XXXExcepiton extends /*Exception */ RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法 &#125; 注意： 自定义异常类一般都是以Exception结尾,说明该类是一个异常类 自定义异常类,必须的继承Exception或者RuntimeException ​ 继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理 这个异常,要么throws,要么try…catch ​ 继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理) 示例： 要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 1234567891011121314public class RegisterException extends /*Exception*/ RuntimeException&#123; //添加一个空参数的构造方法 public RegisterException()&#123; super(); &#125; /* 添加一个带异常信息的构造方法 查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息 */ public RegisterException(String message)&#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627282930313233public class Demo01RegisterException &#123; // 1.使用数组保存已经注册过的用户名(数据库) static String[] usernames = &#123;\"张三\",\"李四\",\"王五\"&#125;; public static void main(String[] args) /*throws RegisterException*/ &#123; //2.使用Scanner获取用户输入的注册的用户名(前端,页面) Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要注册的用户名:\"); String username = sc.next(); checkUsername(username); &#125; //3.定义一个方法,对用户输入的中注册的用户名进行判断 public static void checkUsername(String username) /*throws RegisterException*/ &#123; //遍历存储已经注册过用户名的数组,获取每一个用户名 for (String name : usernames) &#123; //使用获取到的用户名和用户输入的用户名比较 if(name.equals(username))&#123; //true:用户名已经存在,抛出RegisterException异常,告知用户\"亲，该用户名已经被注册\"; try &#123; throw new RegisterException(\"亲，该用户名已经被注册\"); &#125; catch (RegisterException e) &#123; e.printStackTrace(); return; //结束方法 &#125; &#125; &#125; //如果循环结束了,还没有找到重复的用户名,提示用户\"恭喜您,注册成功!\"; System.out.println(\"恭喜您,注册成功!\"); &#125;&#125; 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 创建线程类Thread类：是描述线程的类,我们想要实现多线程程序,就必须继承Thread类 实现步骤： 创建一个Thread类的子类 在Thread类的子类中重写Thread类中的run方法,设置线程任务 创建Thread类的子类对象 调用Thread类中的方法start方法,开启新的线程,执行run方法 注意： void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行 多线程 创建一个Thread类的子类： 12345678910//1.创建一个Thread类的子类public class MyThread extends Thread&#123; //2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?) @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(\"run:\"+i); &#125; &#125;&#125; 使用： 123456789101112public class Demo01Thread &#123; public static void main(String[] args) &#123; //3.创建Thread类的子类对象 MyThread mt = new MyThread(); //4.调用Thread类中的方法start方法,开启新的线程,执行run方法 mt.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(\"main:\"+i); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记11——Map","slug":"Java学习日记11——Map","date":"2020-07-13T05:07:59.257Z","updated":"2020-07-13T13:37:15.639Z","comments":true,"path":"2020/07/13/Java学习日记11——Map/","link":"","permalink":"http://yoursite.com/2020/07/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B011%E2%80%94%E2%80%94Map/","excerpt":"Java学习每一天","text":"Java学习每一天 Map集合特点: Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) Map集合中的元素,key和value的数据类型可以相同,也可以不同 Map集合中的元素,key是不允许重复的,value是可以重复的 Map集合中的元素,key和value是一一对应 常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 Map接口的方法演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125; 遍历keyset()方法public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 12345678910111213141516171819202122232425262728293031public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125; entrySet()方法public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Entry是Map接口的内部类，将键值对的对应关系封装成了对象。即键值对对象。 Entry的方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 分析步骤： 使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 遍历Set集合,获取每一个Entry对象 使用Entry对象中的方法getKey()和getValue()获取键与值 1234567891011121314151617181920212223242526272829303132public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); //使用增强for遍历Set集合 for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 子类HashMap特点： 底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快 ​ DK1.8之前:数组+单向链表 ​ JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 HashMap存储自定义类型键值 Map集合保证key是唯一的：如果自定义类型作为key储存，必须重写hashCode方法和equals方法,以保证key唯一。 LinkedHashMap特点： LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的 Hashtable特点： 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢 不能存储null值，null键 已经被取代了，Hashtable的子类Properties依然活跃在历史舞台 静态方法ofJDK9的新特性: static &lt;E&gt; List&lt;E&gt; of(E... elements)：可以给集合一次性添加多个元素 123456public class Demo01JDK9 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list); // [a, b, a, c, d] &#125;&#125; 注意: of方法只适用于List接口，Set接口，Map接口，不适用于接接口的实现类 of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常 Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常 Debug追踪使用IDEA的断点调试功能，查看程序的运行过程 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 ) Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记10——List、Set、数据结构、Collections","slug":"Java学习日记10——List、Set、数据结构、Collections","date":"2020-07-12T10:41:56.553Z","updated":"2020-07-12T13:49:13.137Z","comments":true,"path":"2020/07/12/Java学习日记10——List、Set、数据结构、Collections/","link":"","permalink":"http://yoursite.com/2020/07/12/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B010%E2%80%94%E2%80%94List%E3%80%81Set%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81Collections/","excerpt":"Java学习每一天","text":"Java学习每一天 数据结构栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 List集合List接口List接口特点 它是一个元素存取有序的集合。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 123456789101112131415161718192021222324252627282930313233public class Demo01List &#123; public static void main(String[] args) &#123; //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] // get方法在普通for循环遍历中体现 &#125;&#125; 3种遍历方式12345678910111213141516171819202122232425262728 //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\");//List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++)&#123; //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用增强for for (String s : list) &#123; System.out.println(s); &#125; List的子类ArrayList集合特点：元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 LinkedList集合特点：数据存储的结构是双向链表结构。元素增删快，查找慢。 常用特有方法 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; /* - public E removeFirst():移除并返回此列表的第一个元素。 同效果：public E pop() - public E removeLast():移除并返回此列表的最后一个元素。 */ private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] &#125; /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear():清空集合中的元素 //public boolean isEmpty():如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; /* - public void addFirst(E e):将指定元素插入此列表的开头。 同效果：public void push(E e) - public void addLast(E e):将指定元素添加到此列表的结尾。 */ private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125; Set接口特点： 不允许存储重复的元素 没有索引,没有带索引的方法,也不能使用普通的for循环遍历 遍历：由于没有索引，遍历方法只有：迭代器、增强for。 HashSet集合特点 不允许存储重复的元素 没有索引,没有带索引的方法,也不能使用普通的for循环遍历 是一个无序的集合,存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构(查询的速度非常的快) 不重复原理元素唯一性的方式依赖于：hashCode与equals方法。 hashCode方法可以返回对象的哈希值（int类型）。 下图讲解了Set对象存储不会重复的原因： 存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] LinkedHashSetLinkedHashSet是HashSet下面的一个子类。 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 可变参数作用：如果传参的时候只能确定参数的类型，不能确定参数的个数（比如1~n个数相加，n不确定），可以使用可变参数。 格式： 1234修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;//可变参数的特殊(终极)写法public static void method(Object...obj)&#123; &#125; 使用 123456789101112131415public class ChangeArgs &#123; public static void main(String[] args) &#123; // 随便输入几个数相加 6 7 2 12 2121 int sum = getSum(6, 7, 2, 12, 2121); System.out.println(sum); &#125; //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; 注意： 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 传递的参数个数，可以是0个(不传递)。 CollectionsaddAll方法和shuffke方法public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) addAll方法：往集合中一次性添加多个元素。 public static void shuffle(List&lt;?&gt; list) shuffke：打乱集合元素顺序。 使用 1234567891011121314public class Demo01Collections &#123; public static void main(String[] args) &#123; // 创建ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\"); System.out.println(list);//[a, b, c, d, e] //public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 Collections.shuffle(list); System.out.println(list); // [c, b, a, e, d] &#125;&#125; sort方法1public static &lt;T&gt; void sort(List&lt;T&gt; list) 作用：将集合中元素按照指定规则排序。 非自定义类型对于非自定义类型的集合，可以直接使用。 1234567891011121314public class Demo01Collections &#123; public static void main(String[] args) &#123; // 创建ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //往集合中添加一些元素。 Collections.addAll(list,\"c\",\"b\",\"a\",\"e\",\"d\"); System.out.println(list); // [c, b, a, e, d] //public static &lt;T&gt; void sort(List&lt;T&gt; list) 给集合排序 Collections.shuffle(list); System.out.println(list); // [a, b, c, d, e] &#125;&#125; 自定义类型对于自定义类型的集合，自定义的类需要连接Comparable接口，泛型为类名，并重写compareTo方法 1234567891011121314public class 类名 implements Comparable&lt;类名&gt;&#123; private String name; private int age; // 省略了构造方法和getter/setter方法 //重写排序的规则 @Override public int compareTo(类名 o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄降序排序 &#125;&#125; sort方法2public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) 作用：将集合中元素按照指定规则排序。 使用 下面以Integer举例，其他类型（包括自定义，自定义o1和o2后指定具体变量）类似。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01); // [3, 2, 1] // 自定义类型 /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;);*/ //扩展:了解 /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;);*/ &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记9——Collection、泛型","slug":"Java学习日记9——Collection、泛型","date":"2020-07-12T04:57:17.924Z","updated":"2020-07-12T13:48:56.808Z","comments":true,"path":"2020/07/12/Java学习日记9——Collection、泛型/","link":"","permalink":"http://yoursite.com/2020/07/12/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B09%E2%80%94%E2%80%94Collection%E3%80%81%E6%B3%9B%E5%9E%8B/","excerpt":"Java学习每一天","text":"Java学习每一天 Collection集合橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。在Collection接口定义着单列集合框架中最最共性的内容。 创建方法：Collection是接口，使用多态的写法创建对象。 12// 子类以ArrayList为例Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection 常用共性方法所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法，方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Demo01Collection &#123; public static void main(String[] args) &#123; //创建集合对象,可以使用多态 //Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); System.out.println(coll);//重写了toString方法 [] /* public boolean add(E e)： 把给定的对象添加到当前集合中 。 返回值是一个boolean值,一般都返回true,所以可以不用接收 */ boolean b1 = coll.add(\"张三\"); System.out.println(\"b1:\"+b1);//b1:true System.out.println(coll);//[张三] coll.add(\"李四\"); coll.add(\"李四\"); coll.add(\"赵六\"); coll.add(\"田七\"); System.out.println(coll);//[张三, 李四, 赵六, 田七] /* public boolean remove(E e): 把给定的对象在当前集合中删除。 返回值是一个boolean值,集合中存在元素,删除元素,返回true 集合中不存在元素,删除失败,返回false */ boolean b2 = coll.remove(\"赵六\"); System.out.println(\"b2:\"+b2);//b2:true boolean b3 = coll.remove(\"赵四\"); System.out.println(\"b3:\"+b3);//b3:false System.out.println(coll);//[张三, 李四, 田七] /* public boolean contains(E e): 判断当前集合中是否包含给定的对象。 包含返回true 不包含返回false */ boolean b4 = coll.contains(\"李四\"); System.out.println(\"b4:\"+b4);//b4:true boolean b5 = coll.contains(\"赵四\"); System.out.println(\"b5:\"+b5);//b5:false //public boolean isEmpty(): 判断当前集合是否为空。 集合为空返回true,集合不为空返回false boolean b6 = coll.isEmpty(); System.out.println(\"b6:\"+b6);//b6:false //public int size(): 返回集合中元素的个数。 int size = coll.size(); System.out.println(\"size:\"+size);//size:3 //public Object[] toArray(): 把集合中的元素，存储到数组中。 Object[] arr = coll.toArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //public void clear() :清空集合中所有的元素。但是不删除集合,集合还存在 coll.clear(); System.out.println(coll);//[] System.out.println(coll.isEmpty());//true &#125;&#125; 注意： 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 遍历集合Iterator迭代器作用：用来遍历集合，Iterator对象也被称为迭代器。 创建：Iterator是接口，无法直接创建对象，Collection集合有专门获取迭代器的方法： 1234567/* public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。*/ // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); 迭代的概念：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法 public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 通过使用上面两个方法实现迭代，示例： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; 注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 使用 遍历数组 123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 遍历集合 123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; 注意：它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 泛型定义的时候先不写参数的类型，使用的时候再确定类型，可以在类或方法中预支地使用未知的类型。 注意：如果在创建对象的时候，还不将未知的类型确定具体的类型。默认类型为Object类型。 泛型的定义与使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如 1234567891011public class GenericClass&lt;E&gt; &#123; private E name; public E getName() &#123; return name; &#125; public void setName(E name) &#123; this.name = name; &#125;&#125; 使用：在创建对象的时候确定泛型 12345//创建GenericClass对象,泛型使用String类型 GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;(); gc3.setName(\"小明\"); String name1 = gc3.getName(); System.out.println(name1); 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 使用：调用方法时，确定泛型的类型 123456789101112public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 调用方法 show(\"123\"); show(666); // 定义含有泛型的方法 public &lt;E&gt; void show2(E mvp) &#123; System.out.println(mvp) &#125; &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如 123public interface GenericInterface&lt;I&gt; &#123; public abstract void method(I i);&#125; 使用 定义类时确定泛型的类型 123456public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123; @Override public void method(String s) &#123; System.out.println(s); &#125;&#125; 始终不确定泛型的类型，直到创建对象时，确定泛型的类型 123456public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt; &#123; @Override public void method(I i) &#123; System.out.println(i); &#125;&#125; 确定泛型： 1234567891011121314public class Demo04GenericInterface &#123; public static void main(String[] args) &#123; //创建GenericInterfaceImpl1对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); // 字符串 //创建GenericInterfaceImpl2对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); // 10 GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); // 8.8 &#125;&#125; 泛型通配符泛型类或者接口作为方法的参数时，如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 注意：只能作为方法的参数使用 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记8——Object类、常用API","slug":"Java学习日记8——Object类、常用API","date":"2020-07-11T05:51:35.570Z","updated":"2020-07-11T12:06:53.572Z","comments":true,"path":"2020/07/11/Java学习日记8——Object类、常用API/","link":"","permalink":"http://yoursite.com/2020/07/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B08%E2%80%94%E2%80%94Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/","excerpt":"Java学习每一天","text":"Java学习每一天 Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; toString方法public String toString()：返回该对象的字符串表示。 用法：所用对象都可以直接调用，默认返回值是对象地址，字符串类型。 1String 变量名 = 对象名.toString(); 重写 如果不希望使用toString方法的默认返回对象地址值，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 equals方法public boolean equals(Object obj)：比较两个对象是否相等 用法：所有的对象都可以直接使用，默认比较的是对象地址值是否相等，返回返回boolean类型 1boolean 变量名 = 对象名.equals(); 重写： 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： Objects类的equals方法在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 用法：直接用Objects类调用，参数为两个需要比较的对象，返回值为boolean类型 1boolean 变量名 = Objects.equals(对象1, 对象2); 本质：还是使用了Object的equals方法，只是解决了空指针异常。 日期时间类Date类构造方法 无参构造 public Date() 12Date date = new Date(); System.out.println(date);// 当前时间，格式：Sun Aug 08 12:23:03 CST 2088 有参构造 public Date(long date) 1234// 参数是long类型Date date = new Date(0L); System.out.println(date);// 输入long类型参数毫秒对应时间，格式不变：Thu Jan 01 08:00:00 CST 1970 以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 提示1： 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 提示2：在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用成员方法public long getTime() 把日期对象转换成对应的时间毫秒值。 12// 参数：无参// 返回值类型：long 使用： 123Date date = new Date();long time = date.getTime(); System.out.println(time);//3742777636267 SimpleDateFormat类SimpleDateFormat类是抽象类DateFormat的子类 构造方法构造方法的参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则 常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 12// 对应的日期格式如：2018-01-16 15:06:38SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); 常用成员方法format方法作用：format方法配合构造方法，把时间对象转换成指定格式的字符串。 用法 12345678910/* 参数类型：Date对象; 返回值类型：String; 使用方法：String 变量名 = SimpleDateFormat对象.format(Date对象)*/ Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 parse方法作用：与format方法相反，把指定格式的字符串转换成时间对象。 用法 123456789/* 参数类型：String; 返回值类型：Date对象; 使用方法：Date 变量名 = SimpleDateFormat对象.format(String变量)*/ DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 Calendar类Calendar是抽象类，日历类。 创建因为Calendar为抽象类，无法直接创建对象，我们通过它的一个静态方法创建其子类对象 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 创建格式： 123// getInstance()方法创建的是子类对象，所以这里用的了多态写法// 创建出来的对象可以直接打印，打印结果是日历数据Calendar cal = Calendar.getInstance(); 静态成员变量Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） 常用成员方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 get方法public int get(int field) 作用：获取指定日历对象中字段的值 用法 123456789101112131415161718/* 参数类型：int 实际用Calendar类的静态成员变量 返回值类型 int 使用方法：int 变量名 = Calendar对象名.get(静态成员变量)*/public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; set方法public void set(int field, int value) 作用：设置日历对象中的数据 用法 123456789101112/* 参数列表：int int 两个int分别是静态成员变量和修改的值 void无返回值 使用方法：Calendar对象名.set(静态成员变量, 修改值)*/public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法public abstract void add(int field, int amount) 作用：可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。 用法 123456789101112131415/* 参数列表：int int 两个int分别是静态成员变量和指向字段增加的值 void无返回值 使用方法：Calendar对象名.add(静态成员变量, 增加值)*/public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法public Date getTime() 作用：获取日历对应的Date对象。 用法 123456789101112/* 无参数 返回值类型：Date 使用方法：Date 对象名 = Calendar对象名.getTime()*/public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 currentTimeMillis方法public static long currentTimeMillis() 作用：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 用法 1234567891011/* 无参数 返回值类型 long 使用方法：long 变量名 = System.currentTimeMillis()*/public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; arraycopy方法public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 作用：将一个数组中指定的数据拷贝到另一个数组中的指定位置。 参数列表 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 用法 1234567891011121314import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; StringBuilder类如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 字符串缓冲区,可以提高字符串的效率 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 12345678910public class StringBuilderDemo &#123; public static void main(String[] args) &#123; // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 常用成员方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法public StringBuilder append(...) 作用：把参数对应的字符串内容添加到StringBuilder中 用法 append方法具有多种重载形式，可以接收任意类型的参数。 123456789101112131415161718192021/* 任意类型 返回值类型：StringBuilder地址 所以不用写接收接收，且可以使用链式编程 使用方法：StringBuilder对象名.append(任意参数);*/public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); // builder:helloworldtrue100 &#125;&#125; StringBuilder和String相互转换 String转StringBuilder: 可以使用StringBuilder的有参构造方法 12StringBuilder sb2 = new StringBuilder(\"itcast\");System.out.println(sb2); // itcast 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 StringBuilder转String: 可以使用StringBuilder中的toString方法 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 包装类如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱与拆箱用Integer举例： 装箱：基本数值—-&gt;包装对象 1234// 法一：使用构造函数函数Integer i = new Integer(4);// 法二：使用包装类中的valueOf方法Integer iii = Integer.valueOf(4); 拆箱：包装对象—-&gt;基本数值 123// 使用包装类中的intValue方法Integer i = new Integer(4);int num = i.intValue(); 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串之间的转换基本类型—-&gt;String 基本类型转换String总共有三种方式 123456789// 法一：直接加上\"\"。（最常用）int i1 = 100;String s1 = i1 + \"\";// 法二：使用包装类的静态方法toString(参数)。String s2 = Integer.toString(100);// 法三：String类的静态方法valueOf(参数)。String s3 = String.valueOf(100); String—-&gt;基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意：如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记7——final、权限、内部类","slug":"Java学习日记7——final、权限、内部类","date":"2020-07-10T13:39:53.321Z","updated":"2020-07-10T15:02:36.416Z","comments":true,"path":"2020/07/10/Java学习日记7——final、权限、内部类/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07%E2%80%94%E2%80%94final%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"Java学习每一天","text":"Java学习每一天 final关键字final关键字代表最终、不可改变的。 注意事项：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 final修饰类含义：当前这个类不能有任何的子类。（太监类）。 格式： 123public final class 类名称 &#123; // ...&#125; final修饰方法含义：这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; final修饰局部变量含义：变量经过一次赋值后，这个变量就不能进行更改。 格式： 1final 数据类型 变量名; final修饰成员变量含义：变量创建时赋值后，这个变量就不能进行更改。 格式： 12修饰符 final 数据类型 变量名 = 值;// 或不直接赋值，通过构造方法赋值 注意： 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 权限1234567891011/*变量使用权限Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private同一个类（我自己） YES YES YES YES同一个包（我邻居） YES YES YES NO不同包子类（我儿子） YES YES NO NO不同包非子类（陌生人） YES NO NO NO注意事项：(default)并不是关键字“default”，而是根本不写。 */ 内部类成员内部类直接定义在一个类内部的类叫做成员内部类。 格式： 123456修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意：内用外，随意访问；外用内，需要内部类对象。 使用方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 1外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 重名： 12345678910111213141516171819// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 注意：局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 使用方法：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 权限： 123456小节一下类的权限修饰符：public &gt; protected &gt; (default) &gt; private定义一个类的时候，权限修饰符规则：1. 外部类：public / (default)2. 成员内部类：public / protected / (default) / private3. 局部内部类：什么都不能写 匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 类和接口的使用类作为成员变量类型原理：实际上类创建的对象做成员变量 举例： 创建武器类Weapon 12345678910111213141516171819public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125; 创建英雄类Hero 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 创建Main 123456789101112131415161718public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"多兰剑\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 接口作为成员变量类型原理：多态写法，实际上时用多态写法创建的对象做成员变量、返回值、参数。 举例： 创建技能接口Skill 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 实现技能接口SkillImpl 123456public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125; 创建英雄类Hero 123456789101112131415161718192021222324252627282930313233343536public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; // 接口作为返回值 return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 创建Main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记6——接口、多态","slug":"Java学习日记6——接口、多态","date":"2020-07-10T06:35:42.215Z","updated":"2020-07-10T08:56:12.966Z","comments":true,"path":"2020/07/10/Java学习日记6——接口、多态/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B06%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/","excerpt":"Java学习每一天","text":"Java学习每一天 接口接口的创建使用创建接口 创建格式跟创建类相似，把public class 类名 换成 public interface 接口名。 在任何版本的Java中，接口都能定义抽象方法。 注意：接口是没有静态代码块或者构造方法的。 创建举例 12345678910111213141516171819202122232425262728/** 接口* 把public class 类名 换成 public interface 接口名** 在任何版本的Java中，接口都能定义抽象方法。* 格式：* public abstract 返回值类型 方法名称(参数列表);** 注意事项：* 1. 接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract* 2. 这两个关键字修饰符，可以选择性的省略。* 3. 方法的三要素，可以随意定义。* */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbstract1(); // 这也是抽象方法 abstract void methodAbstract2(); // 这也是抽象方法 public void methodAbstract3(); // 这也是抽象方法 void methodAbstract4();&#125; 实现类 接口不能直接使用，必须有一个实现类来“实现”接口。 实现类创建格式：public class 实现类名称 implements 接口名称 { // …} 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，如果只是部分重写，那么这个类必须是抽象类。 实现上面接口 123456789101112131415161718192021public class MyInterfaceAbstractImpl implements MyInterfaceAbstract&#123; @Override public void methodAbstract1() &#123; System.out.println(\"这是第一个抽象方法\"); &#125; @Override public void methodAbstract2() &#123; System.out.println(\"这是第二个抽象方法\"); &#125; @Override public void methodAbstract3() &#123; System.out.println(\"这是第三个抽象方法\"); &#125; @Override public void methodAbstract4() &#123; System.out.println(\"这是第四个抽象方法\"); &#125;&#125; 使用举例12345678910111213141516171819202122/** 接口使用步骤：* 1. 接口不能直接使用，必须有一个“实现类”来“实现”接口。* 格式：* public class 实现类名称 implements 接口名称 &#123;* // ...* &#125;* 2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。* 实现：去掉abstract关键字，加上方法体大括号。* 3. 创建实现类的对象，进行使用。** 注意事项：* 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。* */public class Demo01Interface &#123; public static void main(String[] args) &#123; MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbstract1(); // 这是第一个抽象方法 impl.methodAbstract2(); // 这是第二个抽象方法 &#125;&#125; default默认方法从Java 8开始，接口里允许定义默认方法。 作用：因为接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，所以如果给接口升级（添加新的抽象方法），那么已经写好的实现类都要修改，为了防止这样的麻烦，新添加的方法用默认方法，已经写好的实现类就可以直接继承了。 创建格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：可以直接用实现类的对象调用。 static静态方法从Java 8开始，接口当中允许定义静态方法 创建格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：通过接口名称，直接调用其中的静态方法。 private私有方法从Java 9开始，接口当中允许定义私有方法。 只能内部使用，不能调用； 作用：接口内的默认方法或静态方法中可能会有重复代码，如果定义新的默认方法或静态代码来减少重复代码，会导致可调用方法增多，可以通过使用私有方法，减少重复代码，又不会增加可调用方法。 私有方法用法举例： 下面创建一个接口，减少代码重复，但不增加可调用方法。 123456789101112131415161718public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 成员变量【常量】接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。 创建格式： 1public static final 数据类型 常量名称 = 数据值; 调用格式： 1接口名.常量名； 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 多接口 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 格式： 123public class 实现类 implements 接口1, 接口2 &#123; // 覆盖重写所有抽象方法&#125; 重名： 多继承可能会出现重名问题。 抽象方法重名 在实现类中只需要覆盖重写一次即可。 默认方法重名 实现类一定要对冲突的默认方法进行覆盖重写。 父类中方法与默认方法重名 会优先用父类当中的方法。 小结 多态代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式1234格式：父类名称 对象名 = new 子类名称();或者：接口名称 对象名 = new 实现类名称(); 调用规则口诀： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边。 举例： 123456789101112131415public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 // 编译看左边，写出obj.method();，父类有method()方法，编译不报错。 // 运行看右边，在子类找method()方法，找到直接执行子类中的method方法，找不到向上找。 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 向上转型对象的向上转型，就是：父类引用指向之类对象。 向下转型向上转型一定是安全的，没有问题的，正确的。 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 含义：将父类对象，【还原】成本来的子类对象 格式： 12// 类似基本数据类型的强转 int a = (int) 10.6;子类名称 对象名 = (子类名称) 父类对象; 判断：如何才能知道一个父类引用的对象，本来是什么子类？ instanceof可以用来判断对象是否原本属于该子类 12对象 instanceof 类名称// 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 判断举例： 123456789101112131415161718192021222324252627282930313233343536373839/*如何才能知道一个父类引用的对象，本来是什么子类？格式：对象 instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 */public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记5——继承、super、this、抽象类","slug":"Java学习日记5——继承、super、this、抽象类","date":"2020-07-09T13:48:16.108Z","updated":"2020-07-09T14:41:39.210Z","comments":true,"path":"2020/07/09/Java学习日记5——继承、super、this、抽象类/","link":"","permalink":"http://yoursite.com/2020/07/09/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B05%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 继承继承的用法定义员工父类Employee 12345678910/** 定义父类格式（一个普通类的定义）* 定义子类格式：public class 子类名称 extends 父类名称 &#123;&#125;* */public class Employee &#123; public void method()&#123; System.out.println(\"方法执行\"); &#125;&#125; 定义Employee类的子类Teacher 12public class Teacher extends Employee &#123;&#125; 定义Employee类的子类Assistant 12public class Assistant extends Employee &#123;&#125; 使用 1234567891011121314151617public class Demo01Extends &#123; public static void main(String[] args) &#123; // 使用父类 Employee employee = new Employee(); employee.method(); //方法执行 System.out.println(\"===========\"); // 使用子类Teacher Teacher teacher = new Teacher(); teacher.method(); //方法执行 System.out.println(\"=============\"); // 使用子类Assistant Assistant assistant = new Assistant(); assistant.method(); //方法执行 &#125;&#125; 重名变量子类新定义和父类有相同的变量名 定义父类Fu 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 定义子类Zi 1234567public class Zi extends Fu &#123; int num = 200; public void ziShow()&#123; System.out.println(num); &#125;&#125; 父类和子类有重名变量num,使用结果如下 123456789101112public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Fu fu = new Fu(); fu.fuShow(); // 100 System.out.println(\"==========\"); Zi zi = new Zi(); zi.ziShow(); // 200 // fuShow在Fu类中定义，所以使用Fu类的num zi.fuShow(); // 100 &#125;&#125; 局部变量、子类变量、父类变量重名父类 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 子类 123456789public class Zi extends Fu &#123; int num = 200; public void ziShow(int num) &#123; System.out.println(num); // 参数的num System.out.println(this.num); // 子类的num System.out.println(super.num); // 父类的num &#125;&#125; 使用结果 12345678910111213141516171819/** 变量重名问题* 局部变量 直接写变量名* 本类变量 this.变量名* 父类变量 super.变量名* */public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.ziShow(300); &#125;&#125;/*运行结果：300200100*/ 方法的重写重写：子类把继承来的方法重写一遍，添加新的功能 父类 12345678910111213public class Phone &#123; public void call() &#123; System.out.println(\"打电话\"); &#125; public void send() &#123; System.out.println(\"发短信\"); &#125; public void show() &#123; System.out.println(\"显示号码\"); &#125;&#125; 子类 1234567891011public class NewPhone extends Phone&#123; // 重写标记，建议不省略 @Override public void show() &#123; // 调用父类的show方法，节省代码 super.show(); System.out.println(\"显示头像\"); System.out.println(\"显示姓名\"); &#125;&#125; 使用结果 1234567891011121314151617181920212223242526public class Demo01OverRide &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); phone.call(); phone.send(); phone.show(); System.out.println(\"============\"); NewPhone newPhone = new NewPhone(); newPhone.call(); newPhone.send(); newPhone.show(); &#125;&#125;/*运行结果：打电话发短信显示号码============打电话发短信显示号码显示头像显示姓名*/ super的使用super代指父类 父类 12345public class Fu &#123; public Fu() &#123; System.out.println(\"父构造方法执行\"); &#125;&#125; 子类 1234567public class Zi extends Fu &#123; public Zi()&#123; // 这里自动补充super(); // super(); System.out.println(\"子构造方法执行\"); &#125;&#125; 使用及super注意 123456789101112131415161718/** 1. 子类构造方法当中有一个默认隐含的“supper()”调用，所以一定先调用的父类构造，后执行子类构造。* 2. 子类构造可以通过super关键字来调用父类重载构造。* 3. super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。* 总结：* 子类必须调用父类构造方法，不写则赠送super()，写了则用写的指定的super调用，super只能有一个，还必须是第一个。* */public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125;/*运行结果：父构造方法执行子构造方法执行*/ 抽象方法和抽象类抽象方法：就是加上abstract关键字，然后去掉大括号。抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可。 父类 123public abstract class Animal &#123; public abstract void eat();&#125; 子类 123456public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 使用结果 1234567891011121314151617/** 抽象方法：就是加上abstract关键字，然后去掉大括号* 抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可** 如何使用抽象类和抽象方法：* 1. 不能直接创建new抽象类对象。* 2. 必须用一个子类来继承抽象父类。* 3. 子类必须覆盖重写抽象父类当中所有的抽象方法。* 4. 创建子类对象进行使用。* */public class Demo01Abstract &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.eat(); // 猫吃鱼 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记4——String类、static、Arrays类、Math类","slug":"Java学习日记4——String类、static、Arrays类、Math类","date":"2020-07-08T13:19:58.449Z","updated":"2020-07-09T07:44:08.654Z","comments":true,"path":"2020/07/08/Java学习日记4——String类、static、Arrays类、Math类/","link":"","permalink":"http://yoursite.com/2020/07/08/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B04%E2%80%94%E2%80%94String%E7%B1%BB%E3%80%81static%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 String类String类的创建 创建方法 12345678910111213141516171819202122232425262728293031323334/*String类String类的3+1种创建方法 1. 使用空参构造 String 对象名 = new String(); 2. 根据字符数组创建字符串 String 对象名 = new String(char[] array); 3. 根据字节数组创建字符串 String 对象名 = new String(byte[] array); 4. 直接创建 String str = \"Hello\";*/public class Demo01String &#123; public static void main(String[] args) &#123; // 使用空参构造 String str1 = new String(); System.out.println(\"第一个字符串：\" + str1); // 第一个字符串： // 根据字符数组创建字符串 char[] charArray = &#123;'A', 'B', 'C'&#125;; String str2 = new String(charArray); System.out.println(\"第二个字符串：\" + str2); // 第二个字符串：ABC // 根据字节数组创建字符串 byte[] byteArray = &#123;97, 98, 99&#125;; String str3 = new String(byteArray); System.out.println(\"第三个字符串：\" + str3); // 第三个字符串：abc // 直接创建 String str4 = \"Hello!\"; System.out.println(str4); // Hello! &#125;&#125; 字符串常量池 1234567891011121314// 字符串常量池：程序中直接写的引号字符串，就在字符串常量池中// 对引用类型来说，==是进行【地址值】的比较public class Demo02StringPool &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false &#125;&#125; String类成员方法字符串比较1234567891011121314151617181920212223242526272829/*字符串比较1. public boolean equals(Object obj) 区分大小写 用法：对象名.equals(对象名);2. public boolean equalsIgnoreCase(String str); 不区分大小写 用法：对象名.equalsIgnoreCase(对象名);*/public class Demo01StringEquals &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1.equals(str2)); // true System.out.println(str2.equals(str3)); // true String str4 = null;// System.out.println(str4.equals(\"abc\")); // 报错！ System.out.println(str2.equals(\"abc\")); // true 不推荐 System.out.println(\"abc\".equals(str3)); // true 推荐 String str5 = \"Java\"; String str6 = \"java\"; System.out.println(str5.equals(str6)); // false 区分大小写 System.out.println(str5.equalsIgnoreCase(str6)); // true 不区分大小写 &#125;&#125; 字符串——获取长度、指定位置字符、字符串位置、拼接12345678910111213141516171819202122232425262728/** String中与获取相关的方法有** public int length() 获取字符串长度* public String concat(String str) 拼接字符串，返回新的字符串* public char charAt(int index) 获取字符串指定位置的字符（从零开始数）* public int indexOf(String str) 获取参数字符串在本字符串中首次出现的位置，如果没有返回-1* */public class Demo02StringGet &#123; public static void main(String[] args) &#123; // 获取字符串长度 int length = \"hello\".length(); System.out.println(length); // 5 // 拼接字符串 String str1 = \"Hello\".concat(\" World\"); System.out.println(str1); // Hello World // 获取字符串指定位置字符 char ch = str1.charAt(2); System.out.println(ch); // 1 // 获取字符串首次出现的位置 int index = str1.indexOf(\"lo\"); System.out.println(index); // 3 &#125;&#125; 字符串截取1234567891011121314151617181920/** 字符串的截取方法** public String substring(int index) 从参数位置开始一直截取到末尾* public String substring(int begin, int end) 截取begin到end之间的字符串* 备注：[begin,end),包括左边，不包括右边* */public class Demo03Substring &#123; public static void main(String[] args) &#123; // 截取到末尾 String str1 = \"Hello World\"; String str2 = str1.substring(6); System.out.println(str2); // 指定开始结束位置 String str3 = str1.substring(4,8); System.out.println(str3); &#125;&#125; 字符串转数组、替换字符串123456789101112131415161718192021222324252627282930/** String中与转换相关的方法有** public char[] toCharArray() 将字符串拆分成字符数组返回* public byte[] getBytes() 获取当前字符串底层的字节数组* public String replace(CharSequence orderString, CharSequence newString) 替换字符串* */import java.util.Arrays;public class Demo04StringConvert &#123; public static void main(String[] args) &#123; // 转换成字符数组 char[] chars = \"Hello\".toCharArray(); System.out.println(Arrays.toString(chars)); // [H, e, l, l, o] System.out.println(chars.length); // 5 System.out.println(\"=========================\"); // 转换成字节数组 byte[] bytes = \"abc\".getBytes(); System.out.println(Arrays.toString(bytes)); // [97, 98, 99] System.out.println(bytes.length); // 3 System.out.println(\"==========================\"); // 替换字符串 String str1 = \"How do you do?\"; String str2 = str1.replace('o','*'); System.out.println(str2); // H*w d* y*u d*? &#125;&#125; 字符串分割12345678910111213141516171819202122232425/** 字符串分割方法* public String[] split(String regex) 按照参数的规则，把字符串分割成若干段** 注意事项：* split方法的参数其实是一个“正则表达式”* 如果按照英文句点“.”进行分割，必须写成“\\\\.”* */public class Demo05StringSplit &#123; public static void main(String[] args) &#123; String str1 = \"aaa,bbb,ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"======================\"); String str2 = \"jjj.ddd.ggg\"; strArray = str2.split(\"\\\\.\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; &#125;&#125; Static静态静态的使用先定义含有静态成员变量和静态成员方法的类Student 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private int id; private String name; private int age; //静态成员变量 static String room; static int idCounter = 0; //静态成员方法 public static void show()&#123; System.out.println(\"静态成员方法\"); &#125; // 构造方法 public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public Student() &#123; &#125; // getter/setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 使用Student类 123456789101112131415161718192021// static静态成员变量中的数据共享，即该变量属于类，而不属于对象/** 1. 静态不能访问非静态* 2. 推荐静态成员变量个静态成员方法直接用类调用* 3. 静态成员方法不能使用this* */public class demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student(\"郭靖\",19); Student.room = \"黄埔军校\"; System.out.println(\"学号：\"+one.getId()+\"，姓名：\"+one.getName()+\"，年龄：\"+one.getAge()+\"，教室：\"+Student.room); // 教室共享，学号自增 Student two = new Student(\"黄蓉\",18); System.out.println(\"学号：\"+two.getId()+\"，姓名：\"+two.getName()+\"，年龄：\"+two.getAge()+\"，教室：\"+Student.room); // 调用静态成员方法 Student.show(); // 静态成员方法 &#125;&#125; 静态代码块先定义一个含有静态代码块的类Person 12345678910public class Person &#123; // 静态代码块 static &#123; System.out.println(\"这是静态代码块\"); &#125; // 构造方法 public Person()&#123; System.out.println(\"这是构造方法\"); &#125;&#125; 使用Person类 1234567891011121314151617/** 静态代码块：static&#123;&#125;* 1. 静态代码块只在第一次使用类的时候执行一次* 2. 静态代码块先执行* 3. 典型用途：用于一次性的对静态变量赋值* */public class demo03Static &#123; public static void main(String[] args) &#123; Person one = new Person(); /* * 运行结果： * 这是静态代码块 * 这是构造方法 * */ &#125;&#125; Arrays类12345678910111213141516171819202122232425/* * java.util.Arrays是一个与数组相关的工具类 * * public static String toString(数组) 将参数数组变成字符串，格式为“[元素1,元素2,元素3.。。。]” * public static void sort(数组) 按照默认升序（从小到大）对数组排列 * 备注：1. 数字升序排列， * 2. 字符串按字母升序排列 * 3. 如果是自定义类型，那么自定义类型需要有Comparable或者Comparator接口的支持 * */import java.util.Arrays;public class Demo01Arrays &#123; public static void main(String[] args) &#123; int[] intArray = &#123;10, 20, 30&#125;; // 将数组变成字符串 String intStr = Arrays.toString(intArray); System.out.println(intStr); // [10, 20, 30] // 对数组排序 int[] array1 = &#123;2, 1, 3, 10, 6&#125;; Arrays.sort(array1); System.out.println(Arrays.toString(array1)); // [1, 2, 3, 6, 10] &#125;&#125; Math类12345678910111213141516171819202122232425262728293031/** Math是数学工具类** public static double abs(double num) 获取绝对值* public static double ceil(double num) 向上取整* public static double floor(double num) 向下取整* public static long round(double num) 四舍五入* */public class Demo03Math &#123; public static void main(String[] args) &#123; // 获取绝对值 System.out.println(Math.abs(3.14)); // 3.14 System.out.println(Math.abs(-3.14)); // 3.14 System.out.println(\"==============\"); // 向上取整 System.out.println(Math.ceil(3.14)); // 4 System.out.println(Math.ceil(-3.14)); // -3 System.out.println(\"==============\"); // 向下取整 System.out.println(Math.floor(3.14)); // 3 System.out.println(Math.floor(-3.14)); // -4 System.out.println(\"==============\"); // 四舍五入 System.out.println(Math.round(3.14)); // 3 System.out.println(Math.round(-3.14)); // -3 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"HTML学习日记1——HTML新增属性","slug":"HTML学习日记1——HTML新增属性","date":"2020-05-14T03:52:04.049Z","updated":"2020-05-14T04:09:26.730Z","comments":true,"path":"2020/05/14/HTML学习日记1——HTML新增属性/","link":"","permalink":"http://yoursite.com/2020/05/14/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94HTML%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/","excerpt":"学习HTML每一天","text":"学习HTML每一天 h5新增标签新增内容： 标签 作用 header 头部标签 nav 导航栏 aside 侧边栏 article 内容标签 section 某个区域 footer 尾部标签 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;h5新增标签&lt;/title&gt; &lt;style&gt; header&#123; background-color: pink; height: 188px; width: 800px; margin: 20px auto; border-radius: 15px; &#125; nav&#123; background-color: pink; width: 800px; height: 50px; margin: 10px auto; &#125; aside&#123; width: 500px; height: 700px; background-color: skyblue; float: left; &#125; article&#123; width: 500px; height: 700px; background-color: blueviolet; float: left; &#125; footer&#123; background-color: aquamarine; width: 100%; height: 50px; &#125; section&#123; background-color: burlywood; height: 200px; width: 200px; &#125; div:after&#123; /* 清除浮动 */ clear: both; display: block; content: \"\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;头部标签&lt;/header&gt; &lt;nav&gt;导航栏标签&lt;/nav&gt; &lt;div&gt; &lt;aside&gt;侧边栏标签&lt;/aside&gt; &lt;article&gt;内容标签 &lt;section&gt;定义文档的某个区域&lt;/section&gt; &lt;/article&gt; &lt;/div&gt; &lt;footer&gt;尾部标签&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; video和audio标签video视频标签1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;video视频标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- video视频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 poster 视频封面 width 宽度 height 高度 preload 预加载 --&gt; &lt;video src=\"../../source/video/救赎.mp4\" autoplay=\"autoplay\" muted=\"muted\" controls=\"controls\" loop=\"loop\" poster=\"../../source/img/test.png\"&gt;&lt;/video&gt; &lt;/body&gt;&lt;/html&gt; audio音频标签12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;audio音频标签&lt;/title&gt; &lt;!-- video音频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 preload 预加载 --&gt; &lt;/head&gt; &lt;body&gt; &lt;audio src=\"../../source/audio/希望之花.mp3\" autoplay=\"autoplay\" controls=\"controls\" loop=\"loop\"&gt; 当前浏览器不支持audio &lt;/audio&gt; &lt;/body&gt;&lt;/html&gt; input新增表单123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"\"&gt; &lt;ul&gt; &lt;li&gt;邮箱：&lt;input type=\"email\"&gt;&lt;/li&gt; &lt;li&gt;网址：&lt;input type=\"url\"&gt;&lt;/li&gt; &lt;li&gt;日期：&lt;input type=\"date\"&gt;&lt;/li&gt; &lt;li&gt;时间：&lt;input type=\"time\"&gt;&lt;/li&gt; &lt;li&gt;数量：&lt;input type=\"number\"&gt;&lt;/li&gt; &lt;li&gt;手机号：&lt;input type=\"tel\"&gt;&lt;/li&gt; &lt;li&gt;搜索：&lt;input type=\"search\"&gt;&lt;/li&gt; &lt;li&gt;颜色：&lt;input type=\"color\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; input新增属性1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增属性&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 搜索placeholder文字格式设置 */ input::placeholder&#123; color: #8A2BE2; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;!-- 搜索框 属性 作用 required 不能为空 placeholder 框内背景文字，输入文字消失 autofocus 自动聚焦到框中 autocomplete 输入过的内容提示，默认on 注意： 设置placeholder文字格式：input::placeholder &#123;&#125; --&gt; &lt;input type=\"search\" required=\"required\" placeholder=\"搜索\" autofocus=\"autofocus\" autocomplete=\"off\" /&gt; &lt;br /&gt; &lt;!-- 添加文件表单 属性 作用 multiple 加上这个属性后，就可以一次添加多个文件了 --&gt; &lt;input type=\"file\" multiple=\"multiple\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Java学习日记3——Scanner类、Random类、ArrayList类","slug":"Java学习日记3——Scanner类、Random类、ArrayList类","date":"2020-05-13T06:42:38.515Z","updated":"2020-05-13T12:13:20.878Z","comments":true,"path":"2020/05/13/Java学习日记3——Scanner类、Random类、ArrayList类/","link":"","permalink":"http://yoursite.com/2020/05/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B03%E2%80%94%E2%80%94Scanner%E7%B1%BB%E3%80%81Random%E7%B1%BB%E3%80%81ArrayList%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 Scanner类作用：接收键盘输入的内容。 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner; // 导包语句，写在类的外面，可自动生成/* * Scanner是JDK提供的一个类，详情见API。 * * 引用类型的一般使用步骤 * 1. 导包 * 导包格式：import 包路径.类名称; * 如果要使用的目标类和当前类位于同一包下，则可以省略导包语句不写。 * java.lang包下的内容不需要导包。 * 2. 创建 * 格式：类名称 对象名 = new 类名称(); * 3. 使用 * 对象名.成员方法; * */public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 创建Scanner类的对象 // System.in代表从键盘输入 // 括号中不能为空，System.in是目前的固定写法。 Scanner sc = new Scanner(System.in); // 获取从键盘输入的数字 // sc.nextInt()方法用于获取从键盘输入的数字 int num = sc.nextInt(); System.out.println(\"从键盘输入的数字是：\" + num); // 获取从键盘输入的字符串 // sc.next()方法用于获取从键盘输入的字符串 String str = sc.next(); System.out.println(\"从键盘输入的字符串是：\" + str); /*-----注意：从键盘输入的都是字符串，不同的方法是将字符串转变成不同的类型------*/ &#125;&#125; 匿名对象简单使用匿名对象先创建一个Person类备用 123456789// 定义一个Person类public class Person &#123; String name; public void show() &#123; System.out.println(\"我叫：\" + name); &#125;&#125; 简单使用 1234567891011121314151617/** 匿名对象* 创建格式：new 类名();* 注意事项：匿名对象只能使用唯一的一次。* 使用建议：确定只是用一次，可以使用匿名对象。* */public class Demo01Anonymous &#123; public static void main(String[] args) &#123; Person one = new Person(); one.name = \"高圆圆\"; one.show(); System.out.println(\"===============\"); new Person().name = \"一方通行\"; new Person().show(); // 我叫：null &#125;&#125; 匿名对象与方法匿名对象做参数和返回值 123456789101112131415161718192021222324252627282930313233// 匿名对象的使用举例import java.util.Scanner;public class Demo02Anonymous &#123; public static void main(String[] args) &#123; // 直接传值 System.out.println(\"输入第一个数字：\"); int num1 = new Scanner(System.in).nextInt(); System.out.println(\"输入的数字是：\" + num1); // 匿名对象做方法的参数 methodParam(new Scanner(System.in)); // 匿名对象做返回值 Scanner sc = methodReturn(); System.out.println(\"输入第三个数字：\"); int num3 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num3); &#125; // 匿名对象参数方法 public static void methodParam(Scanner sc) &#123; System.out.println(\"输入第二个数字：\"); int num2 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num2); &#125; // 匿名对象做返回值方法 public static Scanner methodReturn() &#123; return new Scanner(System.in); &#125;&#125; Random类作用：产生随机数 123456789101112131415161718192021222324252627282930313233/* * 使用Random类 * 1. 导包 * 2. 创建 * 格式：Random 对象名 = new Random(); * 3. 使用 * 格式：int 变量名 = 对象名.nextInt(); * 括号内没有参数：返回在int范围内区随机数。 * 括号内有一个参数n：返回区间[0,n)上的一个随机数（可以通过加减数字控制区间）。 * */import java.util.Random;public class Demo01Random &#123; public static void main(String[] args) &#123; // 不设定范围 Random r = new Random(); int num = r.nextInt(); System.out.println(\"得到随机数：\" + num); // 设定范围 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(10); System.out.println(\"区间[0，10)上的随机数：\" + num); &#125; // 控制区间 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(5) + 1; System.out.println(\"区间[1,6)上的随机数：\" + num); &#125; &#125;&#125; ArrayList类作用：代替对象数组存在 对象数组创建Person标准类 1234567891011121314151617181920212223242526272829public class Person &#123; String name; // 姓名 int age; // 年龄 // 构造方法 public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // setter/getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 创建使用对象数组 123456789101112131415161718192021// 对象数组// 创建格式：类名[] 对象名 = new 类名[元素个数]public class Demo01Array &#123; public static void main(String[] args) &#123; Person[] array = new Person[3]; // 创建对象数组 Person one = new Person(\"迪丽热巴\",18); Person two = new Person(\"古力娜扎\",28); Person three = new Person(\"马尔扎哈\",38); array[0] = one; array[1] = two; array[2] = three; System.out.println(array[0]); // 地址值 System.out.println(array[1]); // 地址值 System.out.println(array[2]); // 地址值 System.out.println(array[1].name); // 古力娜扎 &#125;&#125; ArrayList类初识ArrayList12345678910111213141516171819202122232425262728/** ArrayList类* ArrayList集合的长度是可以随时变化的* 格式：ArrayList&lt;E&gt; 对象名 = new ArrayList&lt;&gt;();* 其中&lt;E&gt;代表泛型* 泛型：也就是装在集合中的所有元素，全都是是统一类型。* 注意：* 泛型只能是引用类型，不能是基本类型。* 对于ArrayList集合来说，直接打印得到的不是地址值，而是内容* 如果为空，则打印结果为 []* */import java.util.ArrayList;public class Demo02ArrayList &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] list.add(\"赵丽颖\"); System.out.println(list); // [赵丽颖] list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] &#125;&#125; ArrayList的常用方法1234567891011121314151617181920212223242526272829303132333435363738394041/*ArrayList中常用的方法。public boolean add(E e); 向集合当中添加元素，参数的类型和泛型一致，返回值代表添加是否成功。public E get(int index); 从集合中获取元素，参数是索引编号，返回值就是对应位置的元素，索引值从0开始数。public E remove(int index); 从集合当中删除元素，参数是索引编号，返回值就是所被删除的元素，索引值从0开始数。public int size(); 获取集合中元素的个数。*/import java.util.ArrayList;public class Demo03ArrayListMethod &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 添加元素 list.add(\"赵丽颖\"); list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] // 获取元素 String name = list.get(2); System.out.println(\"获取到的人名：\" + name); // 获取到的人名：古力娜扎 // 删除元素 String remove = list.remove(3); System.out.println(\"被删除的人是：\" + remove); // 被删除的人是：玛尔扎哈 System.out.println(list); //[赵丽颖, 迪丽热巴, 古力娜扎] // 获取元素个数 int size = list.size(); System.out.println(size); // 3 &#125;&#125; 包装类123456789101112131415161718192021222324252627/*包装类泛型只能是引用类型，不能是基本类型。为了集合存放基本类型，可以使用包装类。基本类型 包装类（引用类型，包装类位于java.lang包下）byte Byteshort Shortint Integer 【特殊】long Longfloat Floatdouble Doublechar Character 【特殊】boolean Boolean*/import java.util.ArrayList;public class Demo05ArrayListBasic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(100); list.add(200); list.add(300); int num = list.get(1); System.out.println(num); // 200 &#125;&#125; 集合与方法1234567891011121314151617181920212223242526272829303132333435363738// 集合做方法的参数和返回值// 用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。import java.util.ArrayList;import java.util.Random;public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; Random r = new Random(); ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); // 在大集合中放入20个随机数字 for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(20) + 1; // 1~20的随机数 bigList.add(num); &#125; // 调用自定义方法，定义，打印小集合 ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(smallList); &#125; // 定义方法 // 参数和返回值都是集合 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); // 筛选偶数元素，放入小集合 for (int i = 0; i &lt; bigList.size(); i++) &#123; int num; if (bigList.get(i) % 2 == 0) &#123; num = bigList.get(i); smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记2——类与对象","slug":"Java学习日记2——类与对象","date":"2020-05-11T08:07:58.285Z","updated":"2020-05-11T09:35:56.160Z","comments":true,"path":"2020/05/11/Java学习日记2——类与对象/","link":"","permalink":"http://yoursite.com/2020/05/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B02%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"学习Java每一天","text":"学习Java每一天 JDK提供的Arrays类中的toString方法12345678910111213// 使用面向对象的方法打印数组arrayimport java.util.Arrays; // 这行代码是自动生成的，不用管。public class Demo01PrintArray &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; // JDK给我们提供的Arrays类中，有一个toString方法 // 能把数组变成我们想要的字符串 System.out.println(Arrays.toString(array)); &#125;&#125; 类与对象的定义和使用类的定义：类中有两个组成部分：成员变量，成员方法。 12345678910111213141516171819202122232425262728293031/** 类与对象：* 类是对象的模板，对象是类的实体。** 定义一个Studnet类，类有两部分组成* 成员变量：* String name; // 名字* int age; // 年龄* 成员方法：* public void eat()&#123;&#125;; // 吃饭* public void sleep() &#123;&#125;; // 睡觉* public void study() &#123;&#125;; // 学习** 注意事项：* 1. 成员变量直接定义在类当中，在方法外边。* 2. 成员方法不要写static关键字。* */public class Student &#123; String name; int age; public void eat() &#123; System.out.println(\"吃饭饭！\"); &#125;; public void sleep() &#123; System.out.println(\"睡觉觉！\"); &#125;; public void study() &#123; System.out.println(\"学习！\"); &#125;;&#125; 类的使用类的基本使用使用上面定义的类，学习类的基本使用方法 1234567891011121314151617181920212223242526272829303132/** 类的使用：* 1. 导包：也就是指出所需要的类在什么位置。* 导包格式：import 包名称.类名称* 例： import cn.itcast.day06.demo01.Student;* 注意；如果和当前类属于同一个包，则导包语句可以省略不写。* 2. 创建对象：* 类名称 对象名 = new 类名称();* 例：Student stu = new Student();* 3. 使用：* 使用成员变量：对象名.成员变量名。* 使用成员方法：对象名 成员方法名(参数)。* */public class Demo02Student &#123; public static void main(String[] args) &#123; // 1.导包 // 位于同一个包，导包可以省略 // 2.创建 Student stu = new Student(); // 3.使用 // 使用成员变量 System.out.println(stu.name); // null System.out.println(stu.age); // 0 // 使用成员方法 stu.eat(); // 吃饭饭 stu.sleep(); // 睡觉觉 stu.study(); // 学习 &#125;&#125; 对象与方法先定义一个Phone类 123456789101112131415// 定义一个手机类public class Phone &#123; String brand; // 品牌 double price; // 价格 String color; // 颜色 public void call(String who) &#123; System.out.println(\"给\" + who + \"打电话\"); &#125; public void sendMessage() &#123; System.out.println(\"群发短信\"); &#125;&#125; 下面使用上面定义的Phone类 对象可以作为方法的参数 1234567891011121314151617181920// 对象作为方法的参数// 格式：public static 返回值类型 方法名(类名 参数名)&#123;&#125;;// 参数接收到的是对象的地址值public class Demo02PhoneParam &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; method(one); &#125; // 定义对象为参数的方法 public static void method(Phone one)&#123; System.out.println(one.brand); System.out.println(one.price); System.out.println(one.color); &#125;&#125; 对象可以作为方法的返回值 123456789101112131415161718192021// 对象作为方法的返回值// 格式：public static 类名 方法名(参数类型 参数名)&#123;&#125;// 返回值实际上是对象的地址public class Demo03PhoneReturn &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand); System.out.println(two.price); System.out.println(two.color); &#125; // 定义返回值为对象的方法 public static Phone getPhone() &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 局部变量和全局变量12345678910111213141516171819202122232425262728293031/** 局部变量和全局变量的不同* 1. 定义的位置不同【重点】* 局部变量：在方法内定义。* 全局变量：载方法外部，直接在类中定义。* 2. 作用范围不同【重点】* 局部变量：只有在方法当中可以用。* 全局变量：整个类中都可以使用。* 3. 默认值不同【重点】* 局部变量：没有默认值。* 全局变量：有默认值。* 4. 内存的位置不同【了解】* 局部变量：位于栈内存。* 全局变量：位于堆内存。* 5. 生命周期不同【了解】* 局部变量：随着方法进栈而诞生，随着方法出栈而消失。* 全局变量：随着对象创建而诞生，随着对象被垃圾回收而消失。* */public class Demo01VariableDifference &#123; String name; public void methodA()&#123; int num1; int num2 = 20; System.out.println(name); // 全局变量可以在整个类中使用，且有默认值。// System.out.println(num1); // 错误！num没有默认值。 &#125; public void methodB()&#123;// System.out.println(num2); // 错误！局部变量只能在定义变量的方法内使用。 &#125;&#125; 面对对象——封装面对对象有三大特征：封装，继承，多态。 封装在Java中体现 方法就是一种封装 123456789101112131415public class Demo02Method &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 50, 6000&#125;; System.out.println(getMax(array)); &#125; // 定义一个方法，返回一个数组的最大值。 public static int getMax(int[] array) &#123; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = max &gt; array[i] ? max : array[i]; &#125; return max; &#125;&#125; 关键字private也是一种封装 定义Person类，并将age变量加上private。并学习setter/getter方法 1234567891011121314151617181920212223242526/** 定义Person类，并将age变量加上private。** private效果：可是使加private的变量可以在类中被访问，但无法在类外被直接访问。* 间接访问private变量的方法：添加一对setter方法和getter方法。* 方法名：setter方法和getter方法的方法名格式必须为setXxx和getXxx* 作用：可以防止错误和恶意修改*/public class Person &#123; String name; // 名字 private int age; // 年龄 public void show()&#123; System.out.println(\"姓名：\"+name+\"，年龄：\"+age); &#125; public void setAge(int a)&#123; if(a&gt;=0&amp;&amp;a&lt;=100)&#123; age = a; &#125; else &#123; System.out.println(\"输入数据错误！\"); &#125; &#125; public int getAge()&#123; return age; &#125;&#125; 使用Person类，查看private的效果 1234567891011121314public class Demo03Person &#123; public static void main(String[] args) &#123; Person person = new Person(); person.show(); System.out.println(\"=================\"); person.name = \"赵丽颖\";// person.age = 18; // 错误写法！age有private修饰，无法直接访问。 person.setAge(-20); // 年龄不可以为负数，修改失败！ person.show(); System.out.println(\"=====================\"); person.setAge(18); // 修改成功。 person.show(); &#125;&#125; 注意：boolean类型的成员看变量的getter方法的方法名为isXxx。 this关键字this关键字用于解决成员方法的参数和成员变量重名的问题，下面使用this关键字定义一个Person类。 123456789101112// 定义Person类// 当成员方法中的参数和成员变量重名时，用this关键字来区分// this代指调用方法的对象public class Person &#123; String name; // 姓名 public void sayHello(String name)&#123; System.out.println(this); // 打印调用该方法的对象的地址值 System.out.println(name+\"，你好，我是\"+this.name); &#125;&#125; 可见，this在这里代指调用方法的对象。 构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243/** 构造方法：专门用来创建对象的方法（创建对象时，new后面的那个方法）。* 格式：class 类名(参数类型 参数名)&#123;* 方法体;* &#125;* 注意事项；* 1. 构造方法的名称必须和类名称一样（包括大小写）。* 2. 构造方法不写返回值类型。* 3. 不写构造方法编译器会默认赠送一个没有参数，没有方法体的构造方法。* 4. 一旦编译至少一个构造方法，编译器将不再赠送。* 5. 构造方法是可以重载的。* */public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法（无参） public Student()&#123; System.out.println(\"构造方法执行啦\"); &#125; // 构造方法（全参） public Student(String name,int age)&#123; this.name = name; this.age = age; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 标准类1234567891011121314151617181920212223242526272829303132333435363738394041/** 定义一个标准类。* 标准类四个组成部分* 1. 所有成员变量都要用private关键字修饰。* 2. 为每一对成员变量编写一对getter/setter方法* 3. 编写一个无参数的构造方法。* 4. 编写一个全参数的构造方法。** 这样标准的类也叫做Java Bean* 使用Alt+Ins组合键可以生成代码。*/public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"next使用日志（扩展篇）","slug":"next使用日志（扩展篇）","date":"2020-05-04T17:49:40.577Z","updated":"2020-05-13T13:00:56.796Z","comments":true,"path":"2020/05/05/next使用日志（扩展篇）/","link":"","permalink":"http://yoursite.com/2020/05/05/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%EF%BC%88%E6%89%A9%E5%B1%95%E7%AF%87%EF%BC%89/","excerpt":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步","text":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步 添加动漫小人在博客根目录下执行命令 1npm install --save hexo-helper-live2d 执行上面代码之后，变可以选择要安装的动画了，选择参考https://huaji8.top/post/live2d-plugin-2.0/ 找到自己喜欢的动画之后，执行下面命令 1npm install live2d-widget-model-koharu 注意，上面命令最后的koharu是你选择的动画名，我这里是以koharu举例 安装完成后，要想要显示出来，还需要在站点配置文件添加下面代码 1234567891011121314151617#二次元live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu # 注意这里的koharu是上面安装的动画名字 display: position: right #在屏幕上的显示位置 width: 85 #显示宽度 height: 170 #显示高度 mobile: show: false #手机端是否显示 不想再使用这个插件的时候，可以执行下面命令卸载 1npm uninstall hexo-helper-live2d 方法来源：https://blog.csdn.net/wugenqiang/article/details/88375517 调整内容宽度因为默认内容宽度太窄，代码经常会显示不全，会生成滚动条，看起来特别不方便。 找到文件Hexo/themes/next/source/css/_custom/custom.styl 在里面添加代码 123.header&#123; width: 70%; &#125; /* 80% */.container .main-inner &#123; width: 70%; &#125; /* 80% */.content-wrap &#123; width: calc(100% - 260px); &#125; 注意百分比要一致。 方法来源1：https://github.com/iissnan/hexo-theme-next/issues/759 方法来源2：https://blog.zuiyu1818.cn/posts/NexT_codewidth.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"next使用日志（问题篇）","slug":"next使用日志","date":"2020-05-04T07:47:49.916Z","updated":"2020-05-04T17:48:26.891Z","comments":true,"path":"2020/05/04/next使用日志/","link":"","permalink":"http://yoursite.com/2020/05/04/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/","excerpt":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。","text":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。 菜单项的链接正常打开 去掉||前的空格才会生效 第一个斜杠代表博客主页的相对目录，写网址的话需要删除第一个 / 正常使用分类和标签按操作要求打开分类和标签的菜单项之后，发现这两个功能并不能使用，在博客根目录下执行代码 123hexo new page \"about\"hexo new page \"tags\"hexo new page \"categories\" 这三行代码会在博客根目录下的source目录中创建about、tags、categories三个文件夹，并分别创建index.md文件，分别修改这三个文件 1234567# title和date是自动生成的，只需要添加type即可，type引号内是文件名（不带扩展名）# title是博客显示的名字，如果不写，默认显示文件名# date是博客发表时间，如果不写，默认显示文件创建时间title: categoriesdate: 2018-03-02 12:33:16type: \"categories\" 点击日志错误显示侧栏下面的日志应该和归档有相同的效果，但是实际上点击日志只会显示错误代码，解决方法是找到themes/next/_config.yml 文件下将archives：/archives/ || archive 改成archives：/archives/ 未解决问题 点击日程表错误 点击站点地图错误 关于怎么写入内容 标签和分类都是英文","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Java学习日记1——数组","slug":"Java学习日记1——数组","date":"2020-05-03T12:17:09.305Z","updated":"2020-05-11T09:13:18.965Z","comments":true,"path":"2020/05/03/Java学习日记1——数组/","link":"","permalink":"http://yoursite.com/2020/05/03/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"学习Java每一天","text":"学习Java每一天 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+V 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标所在下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+向上箭头 移动当前代码 Shift+F6 修改所有同名字符 Alt+/ 代码提示 数组数组的初始化a. 数组的初始化分为 静态初始化 1234567// 一般的静态初始化int[] array0 = new int[]&#123;20, 30, 40&#125;; // 静态初始化的省略格式 int[] array1 = &#123; 5, 25, 35 &#125;; // 分成两步初始化，分成两步来写就不能使用省略格式了 int[] array2; array2 = new int[] &#123; 2, 3, 5 &#125;; 动态初始化 123456// 一般的动态初始化int[] array0 = new int[3];// 分成两步的动态初始化int[] array1;array1 = new int[3];System.out.println(array1); // 直接打印数组名称，得到数组对应的，内存地址哈希值 b. 初始化的默认值 1234567891011121314151617181920/** 使用动态初始化的时候，其中的元素将会自动拥有一个默认值，规则如下：* 1. 如果是整数类型，那么默认值为0；* 2. 如果是浮点类型，那么默认值为0。0* 3. 如果是字符类型，那么默认值为' \\u0000'；* 4. 如果是字符串类型，那么默认值为null；* 5. 如果是布尔类型，那么默认值为false*/public class Demo05ArrayUse &#123; public static void main(String[] args) &#123; int[] array = new int[3]; System.out.println(array); // 内存地址哈希值 System.out.println(array[0]); // 0 System.out.println(array[1]); // 0 System.out.println(array[2]); // 0 array[1] = 123; System.out.println(array[1]); // 123 &#125;&#125; 数组的错误 越界异常 123456789101112// 如果访问数组编号的时候，索引编号不存在，那么将会发生数组索引越界异常public class Demo01ArrayIndex &#123; public static void main(String[] args) &#123; int[] array = &#123; 5, 25, 35 &#125;; // 错误写法 // 不存在第三号元素，所以发生异常 System.out.println(array[3]); &#125;&#125; 空指针异常 123456789101112// 所有索引类型变量，都可以赋值为一个null值。但是代表其中什么都没有。/*数组必须进行new初始化才能使用其中的元素。如果只赋值了一个null，没有进行new创建那么就会发生：空指针异常 NullPointerException*/public class Demo02ArrayNull &#123; public static void main(String[] args) &#123; int[] array = null; System.out.println(array[0]); &#125;&#125; 数组与方法 数组作为方法的参数 12345678910111213141516171819202122/** 数组作为参数* 参数写法：数据类型[] 参数名称* 传输内容：数组的地址* */public class Demo01ArrayParam &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; System.out.println(array); System.out.println(\"====================\"); arrayPrint(array); &#125; // 定义数组作为参数，遍历数组的方法 public static void arrayPrint(int[] array)&#123; System.out.println(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 数组作为方法的返回值 1234567891011121314151617181920212223/* * 数组作为方法的返回值 * 方法定义个格式： public static 数组类型[] 函数名称（）&#123;&#125; * 返回内容；数组的地址类型*/public class Demo02ArrayReturn &#123; public static void main(String[] args) &#123; int[] array = calculate(2,4); System.out.println(array); System.out.println(array[0]); System.out.println(array[1]); &#125; // 定义方法 public static int[] calculate(int a, int b) &#123; int sum = a + b; int ave = sum / 2; int[] array = &#123;sum, ave&#125;; System.out.println(array); System.out.println(\"==================\"); return array; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"yilia主题优化日志","slug":"yilia主题优化日志（持续更新）","date":"2020-05-02T04:52:29.258Z","updated":"2020-05-04T17:17:31.435Z","comments":true,"path":"2020/05/02/yilia主题优化日志（持续更新）/","link":"","permalink":"http://yoursite.com/2020/05/02/yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法","text":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法 一. 所有文章 功能刚clone的yilia主题左边的所有文章功能不能用，要进行一下操作 在博客根目录下执行命令 1cnpm i hexo-generator-json-content --save 在hexo的配置文件_config.yml最后添加 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 参考地址：https://blog.csdn.net/qq_32337109/article/details/78756041 二、截断文章博客内容默认是全部显示出来，这样显示全文按钮即没用又不好看。 截断标记 写博客的时候，在想要截断的地方写 1&lt;!--more--&gt; 此时就可以在这个位置截断文章了 隐藏截断标记 使用截断标记虽然可以实现截断文章的效果，但会出现一个标记，和显示全文按钮功能重复，我们可以打开yilia目录下的_config.yml文件，找到 1excerpt_link: more 把more改为空格，完成。 参考地址：https://www.jianshu.com/p/46660e506da5 三、基础设置12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述 # 站点描述keywords: # 博客关键字author: 作者 # 作者language: en # 语言timezone: '' # 时间 四、在左侧显示文章总数在 themes\\yilia\\layout_partial 文件夹下的left-col.ejs文件中 1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 后加上 123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"}]},{"title":"Hexo blog部署","slug":"Hexo blog部署","date":"2020-05-01T14:18:39.446Z","updated":"2020-05-04T17:11:23.198Z","comments":true,"path":"2020/05/01/Hexo blog部署/","link":"","permalink":"http://yoursite.com/2020/05/01/Hexo%20blog%E9%83%A8%E7%BD%B2/","excerpt":"这篇笔记记录了我开始使用博客的详细操作步骤","text":"这篇笔记记录了我开始使用博客的详细操作步骤 1. 下载安装node.js下载node.js 2.Hexo blog部署12npm install -g cnpm --registry=https://registry.npm.taobao.org //安装淘宝镜像cnpm install -g hexo-cli //安装hexo 在命令行操作的初始目录下创建文件夹 blog 12345cd blog //进入blog文件夹hexo init //创建一个博客hexo g //生成博客hexo s //在本地查看生成的blogcnpm install hexo-deployer-git --save //安装推到GitHub的插件 在GitHub上创建一个名为GitHub名.github.io的仓库，打开blog文件夹，找到并修改文件_config.yml，修改部分在底部，这是修改结果 123type: gitrepo: https://github.com/GitHub名/GitHub名.github.io.gitbranch: master 命令行 1hexo d //部署到远端 以上，hexo博客部署完成，此时https://GitHub名.github.io就可以访问自己的博客。 3.更换主题以更换yilia主题为例 yilia主题网址：https://github.com/litten/hexo-theme-yilia 12cd blog //进入blog文件夹git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 打开blog文件夹，找到并修改文件_config.yml，在的 73 行左右，可以看到配置的默认主题theme: landscape，所对应的是 themes 目录下的 landscape 目录。把landscape改为yilia。 1theme: yilia 命令行 1234hexo clean //清理hexo g //生成博客hexo s //本地查看hexo d //部署到远端 更换主题完成。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}