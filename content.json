{"meta":{"title":"梁山好岗のBLOG","subtitle":"就算是梦话也无妨，再说给我听听吧","description":"站点描述","author":"梁山好岗","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T07:01:20.000Z","updated":"2020-05-04T07:04:46.242Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-04T07:01:49.000Z","updated":"2020-05-04T07:06:03.220Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T07:01:36.000Z","updated":"2020-05-04T07:05:32.380Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java学习日记12——异常、线程","slug":"Java学习日记12——异常、线程","date":"2020-07-13T11:02:20.205Z","updated":"2020-07-13T13:34:21.175Z","comments":true,"path":"2020/07/13/Java学习日记12——异常、线程/","link":"","permalink":"http://yoursite.com/2020/07/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B012%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/","excerpt":"Java学习每一天","text":"Java学习每一天 异常异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 12345678910111213141516171819public class Demo02Exception &#123; public static void main(String[] args) &#123; //创建int类型的数组,并赋值 int[] arr = &#123;1,2,3&#125;; int e = getElement(arr,3); System.out.println(e); &#125; /* 定义一个方法,获取数组指定索引处的元素 参数: int[] arr int index */ public static int getElement(int[] arr,int index)&#123; int ele = arr[index]; return ele; &#125;&#125; 上述程序执行过程图解： 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throwthrow用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 注意: throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出指定的异常对象,我们就必须处理这个异常对象 ​ throw关键字后边创建的是RuntimeException或者是 RuntimeException的子类对象,我们可以不处理, 默认交给JVM处理(打印异常对象,中断程序) ​ throw关键字后边创建的是编译异常(写代码的时候报错)，我们就必须处理这个异常，要么throws，要 么try…catch 示例： 1234567891011121314151617181920212223public class ThrowDemo &#123; public static void main(String[] args) &#123; //根据索引找对应的元素 int index = 4; int element = getElement(index); System.out.println(element); &#125; // 返回索引对应地元素 public static int getElement(int index)&#123; //创建一个数组 int[] arr = &#123;2, 4, 52, 2&#125;; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; // ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理 throw new ArrayIndexOutOfBoundsException(\"越界异常\"); &#125; int element = arr[index]; return element; &#125;&#125; Objects非空判断public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 用这个方法可以用来判断空指针异常，不需要我们自己写代码判断空指针。 12345678public static void method(Object obj)&#123; //对传递过来的参数进行合法性判断,判断是否为null /*if(obj == null)&#123; throw new NullPointerException(\"传递的对象的值是null\"); &#125;*/ //Objects.requireNonNull(obj); Objects.requireNonNull(obj,\"传递的对象的值是null\"); 声明异常throws声明异常：如果方法内通过throw抛出了编译时异常(写代码的时候报错)，我们就必须处理这个异常，要么throws，要么try…catch 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 示例 若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 1234567891011121314151617public class ThrowsDemo2 &#123; // main方法再次抛出，交给Jvm处理 public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; // FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常 public static void read(String path)throws FileNotFoundException, IOException &#123; //如果不是 a.txt这个文件，则抛出异常 if (!path.equals(\"a.txt\")) &#123; throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 捕获异常try…catch捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 格式： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意：try和catch都不能单独使用,必须连用。 示例： 1234567891011121314151617181920public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123; // 可能出现异常的代码 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123; //try中抛出的是什么异常，在括号中就定义什么异常类型 // 打印异常 System.out.println(e); &#125; System.out.println(\"over\"); &#125; public static void read(String path) throws FileNotFoundException &#123; //如果不是 a.txt这个文件，则抛出异常 if (!path.equals(\"a.txt\")) &#123; throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 finally 代码块在finally代码块中存放的代码无论异常是否发生，都是一定会被执行的。 注意: finally不能单独使用,必须和try一起使用 finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO) 格式： 123456789101112try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,异常异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch(异常类名 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 示例： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 多个异常使用捕获3种处理方法 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Demo01Exception &#123; public static void main(String[] args) &#123; //1. 多个异常分别处理。 try &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125; try&#123; List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125; //2. 多个异常一次捕获，多次处理。 try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125; /* 一个try多个catch注意事项: catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错 ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException */ /*try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (IndexOutOfBoundsException e)&#123; System.out.println(e); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(e); &#125;*/ //3. 多个异常一次捕获一次处理。 try &#123; int[] arr = &#123;1,2,3&#125;; //System.out.println(arr[3]);//ArrayIndexOutOfBoundsException: 3 List&lt;Integer&gt; list = List.of(1, 2, 3); System.out.println(list.get(3));//IndexOutOfBoundsException: Index 3 out-of-bounds for length 3 &#125;catch (Exception e)&#123; System.out.println(e); &#125; 注意： 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 自定义异常java提供的异常类,不够我们使用,需要自己定义一些异常类 格式： 12345// 继承于Exception或RuntimeExceptionpublic class XXXExcepiton extends /*Exception */ RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法 &#125; 注意： 自定义异常类一般都是以Exception结尾,说明该类是一个异常类 自定义异常类,必须的继承Exception或者RuntimeException ​ 继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理 这个异常,要么throws,要么try…catch ​ 继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理) 示例： 要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 1234567891011121314public class RegisterException extends /*Exception*/ RuntimeException&#123; //添加一个空参数的构造方法 public RegisterException()&#123; super(); &#125; /* 添加一个带异常信息的构造方法 查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息 */ public RegisterException(String message)&#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627282930313233public class Demo01RegisterException &#123; // 1.使用数组保存已经注册过的用户名(数据库) static String[] usernames = &#123;\"张三\",\"李四\",\"王五\"&#125;; public static void main(String[] args) /*throws RegisterException*/ &#123; //2.使用Scanner获取用户输入的注册的用户名(前端,页面) Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要注册的用户名:\"); String username = sc.next(); checkUsername(username); &#125; //3.定义一个方法,对用户输入的中注册的用户名进行判断 public static void checkUsername(String username) /*throws RegisterException*/ &#123; //遍历存储已经注册过用户名的数组,获取每一个用户名 for (String name : usernames) &#123; //使用获取到的用户名和用户输入的用户名比较 if(name.equals(username))&#123; //true:用户名已经存在,抛出RegisterException异常,告知用户\"亲，该用户名已经被注册\"; try &#123; throw new RegisterException(\"亲，该用户名已经被注册\"); &#125; catch (RegisterException e) &#123; e.printStackTrace(); return; //结束方法 &#125; &#125; &#125; //如果循环结束了,还没有找到重复的用户名,提示用户\"恭喜您,注册成功!\"; System.out.println(\"恭喜您,注册成功!\"); &#125;&#125; 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 创建线程类Thread类：是描述线程的类,我们想要实现多线程程序,就必须继承Thread类 实现步骤： 创建一个Thread类的子类 在Thread类的子类中重写Thread类中的run方法,设置线程任务 创建Thread类的子类对象 调用Thread类中的方法start方法,开启新的线程,执行run方法 注意： void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。 java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行 多线程 创建一个Thread类的子类： 12345678910//1.创建一个Thread类的子类public class MyThread extends Thread&#123; //2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?) @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(\"run:\"+i); &#125; &#125;&#125; 使用： 123456789101112public class Demo01Thread &#123; public static void main(String[] args) &#123; //3.创建Thread类的子类对象 MyThread mt = new MyThread(); //4.调用Thread类中的方法start方法,开启新的线程,执行run方法 mt.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(\"main:\"+i); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记11——Map","slug":"Java学习日记11——Map","date":"2020-07-13T05:07:59.257Z","updated":"2020-07-13T13:37:15.639Z","comments":true,"path":"2020/07/13/Java学习日记11——Map/","link":"","permalink":"http://yoursite.com/2020/07/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B011%E2%80%94%E2%80%94Map/","excerpt":"Java学习每一天","text":"Java学习每一天 Map集合特点: Map集合是一个双列集合,一个元素包含两个值(一个key,一个value) Map集合中的元素,key和value的数据类型可以相同,也可以不同 Map集合中的元素,key是不允许重复的,value是可以重复的 Map集合中的元素,key和value是一一对应 常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 Map接口的方法演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class Demo01Map &#123; public static void main(String[] args) &#123; show04(); &#125; /* boolean containsKey(Object key) 判断集合中是否包含指定的键。 包含返回true,不包含返回false */ private static void show04() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); boolean b1 = map.containsKey(\"赵丽颖\"); System.out.println(\"b1:\"+b1);//b1:true boolean b2 = map.containsKey(\"赵颖\"); System.out.println(\"b2:\"+b2);//b2:false &#125; /* public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 返回值: key存在,返回对应的value值 key不存在,返回null */ private static void show03() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); Integer v1 = map.get(\"杨颖\"); System.out.println(\"v1:\"+v1);//v1:165 Integer v2 = map.get(\"迪丽热巴\"); System.out.println(\"v2:\"+v2);//v2:null &#125; /* public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 返回值:V key存在,v返回被删除的值 key不存在,v返回null */ private static void show02() &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); System.out.println(map);//&#123;林志玲=178, 赵丽颖=168, 杨颖=165&#125; Integer v1 = map.remove(\"林志玲\"); System.out.println(\"v1:\"+v1);//v1:178 System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; //int v2 = map.remove(\"林志颖\");//自动拆箱 NullPointerException Integer v2 = map.remove(\"林志颖\"); System.out.println(\"v2:\"+v2);//v2:null System.out.println(map);//&#123;赵丽颖=168, 杨颖=165&#125; &#125; /* public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 返回值:v 存储键值对的时候,key不重复,返回值V是null 存储键值对的时候,key重复,会使用新的value替换map中重复的value,返回被替换的value值 */ private static void show01() &#123; //创建Map集合对象,多态 Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); String v1 = map.put(\"李晨\", \"范冰冰1\"); System.out.println(\"v1:\"+v1);//v1:null String v2 = map.put(\"李晨\", \"范冰冰2\"); System.out.println(\"v2:\"+v2);//v2:范冰冰1 System.out.println(map);//&#123;李晨=范冰冰2&#125; map.put(\"冷锋\",\"龙小云\"); map.put(\"杨过\",\"小龙女\"); map.put(\"尹志平\",\"小龙女\"); System.out.println(map);//&#123;杨过=小龙女, 尹志平=小龙女, 李晨=范冰冰2, 冷锋=龙小云&#125; &#125;&#125; 遍历keyset()方法public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 12345678910111213141516171819202122232425262728293031public class Demo02KeySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法keySet(),把Map集合所有的key取出来,存储到一个Set集合中 Set&lt;String&gt; set = map.keySet(); //2.遍历set集合,获取Map集合中的每一个key //使用迭代器遍历Set集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String key = it.next(); //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-------------------\"); //使用增强for遍历Set集合 for(String key : set)&#123; //3.通过Map集合中的方法get(key),通过key找到value Integer value = map.get(key); System.out.println(key+\"=\"+value); &#125; &#125;&#125; entrySet()方法public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Entry是Map接口的内部类，将键值对的对应关系封装成了对象。即键值对对象。 Entry的方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 分析步骤： 使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 遍历Set集合,获取每一个Entry对象 使用Entry对象中的方法getKey()和getValue()获取键与值 1234567891011121314151617181920212223242526272829303132public class Demo03EntrySet &#123; public static void main(String[] args) &#123; //创建Map集合对象 Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"赵丽颖\",168); map.put(\"杨颖\",165); map.put(\"林志玲\",178); //1.使用Map集合中的方法entrySet(),把Map集合中多个Entry对象取出来,存储到一个Set集合中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); //2.遍历Set集合,获取每一个Entry对象 //使用迭代器遍历Set集合 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while(it.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = it.next(); //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; System.out.println(\"-----------------------\"); //使用增强for遍历Set集合 for(Map.Entry&lt;String,Integer&gt; entry:set)&#123; //3.使用Entry对象中的方法getKey()和getValue()获取键与值 String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key+\"=\"+value); &#125; &#125;&#125; 注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 子类HashMap特点： 底层是一个哈希表，是一个线程不安全的集合，是多线程的集合，速度快 ​ DK1.8之前:数组+单向链表 ​ JDK1.8之后:数组+单向链表|红黑树(链表的长度超过8):提高查询的速度 hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致 HashMap存储自定义类型键值 Map集合保证key是唯一的：如果自定义类型作为key储存，必须重写hashCode方法和equals方法,以保证key唯一。 LinkedHashMap特点： LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序) LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的 Hashtable特点： 底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢 不能存储null值，null键 已经被取代了，Hashtable的子类Properties依然活跃在历史舞台 静态方法ofJDK9的新特性: static &lt;E&gt; List&lt;E&gt; of(E... elements)：可以给集合一次性添加多个元素 123456public class Demo01JDK9 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"a\", \"b\", \"a\", \"c\", \"d\"); System.out.println(list); // [a, b, a, c, d] &#125;&#125; 注意: of方法只适用于List接口，Set接口，Map接口，不适用于接接口的实现类 of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常 Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常 Debug追踪使用IDEA的断点调试功能，查看程序的运行过程 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 ) Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记10——List、Set、数据结构、Collections","slug":"Java学习日记10——List、Set、数据结构、Collections","date":"2020-07-12T10:41:56.553Z","updated":"2020-07-12T13:49:13.137Z","comments":true,"path":"2020/07/12/Java学习日记10——List、Set、数据结构、Collections/","link":"","permalink":"http://yoursite.com/2020/07/12/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B010%E2%80%94%E2%80%94List%E3%80%81Set%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81Collections/","excerpt":"Java学习每一天","text":"Java学习每一天 数据结构栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 List集合List接口List接口特点 它是一个元素存取有序的集合。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 123456789101112131415161718192021222324252627282930313233public class Demo01List &#123; public static void main(String[] args) &#123; //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\"); //打印集合 System.out.println(list);//[a, b, c, d, a] 不是地址重写了toString //public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 //在c和d之间添加一个itheima list.add(3,\"itheima\");//[a, b, c, itheima, d, a] System.out.println(list); //public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 //移除元素 String removeE = list.remove(2); System.out.println(\"被移除的元素:\"+removeE);//被移除的元素:c System.out.println(list);//[a, b, itheima, d, a] //public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 //把最后一个a,替换为A String setE = list.set(4, \"A\"); System.out.println(\"被替换的元素:\"+setE);//被替换的元素:a System.out.println(list);//[a, b, itheima, d, A] // get方法在普通for循环遍历中体现 &#125;&#125; 3种遍历方式12345678910111213141516171819202122232425262728 //创建一个List集合对象,多态 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //使用add方法往集合中添加元素 list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"a\");//List集合遍历有3种方式 //使用普通的for循环 for(int i=0; i&lt;list.size(); i++)&#123; //public E get(int index):返回集合中指定位置的元素。 String s = list.get(i); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用迭代器 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(\"-----------------\"); //使用增强for for (String s : list) &#123; System.out.println(s); &#125; List的子类ArrayList集合特点：元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 LinkedList集合特点：数据存储的结构是双向链表结构。元素增删快，查找慢。 常用特有方法 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Demo02LinkedList &#123; public static void main(String[] args) &#123; show03(); &#125; /* - public E removeFirst():移除并返回此列表的第一个元素。 同效果：public E pop() - public E removeLast():移除并返回此列表的最后一个元素。 */ private static void show03() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //String first = linked.removeFirst(); String first = linked.pop(); System.out.println(\"被移除的第一个元素:\"+first); String last = linked.removeLast(); System.out.println(\"被移除的最后一个元素:\"+last); System.out.println(linked);//[b] &#125; /* - public E getFirst():返回此列表的第一个元素。 - public E getLast():返回此列表的最后一个元素。 */ private static void show02() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); //linked.clear():清空集合中的元素 //public boolean isEmpty():如果列表不包含元素，则返回true。 if(!linked.isEmpty())&#123; String first = linked.getFirst(); System.out.println(first);//a String last = linked.getLast(); System.out.println(last);//c &#125; &#125; /* - public void addFirst(E e):将指定元素插入此列表的开头。 同效果：public void push(E e) - public void addLast(E e):将指定元素添加到此列表的结尾。 */ private static void show01() &#123; //创建LinkedList集合对象 LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); //使用add方法往集合中添加元素 linked.add(\"a\"); linked.add(\"b\"); linked.add(\"c\"); System.out.println(linked);//[a, b, c] //public void addFirst(E e):将指定元素插入此列表的开头。 //linked.addFirst(\"www\"); linked.push(\"www\"); System.out.println(linked);//[www, a, b, c] //public void addLast(E e):将指定元素添加到此列表的结尾。此方法等效于 add() linked.addLast(\"com\"); System.out.println(linked);//[www, a, b, c, com] &#125;&#125; Set接口特点： 不允许存储重复的元素 没有索引,没有带索引的方法,也不能使用普通的for循环遍历 遍历：由于没有索引，遍历方法只有：迭代器、增强for。 HashSet集合特点 不允许存储重复的元素 没有索引,没有带索引的方法,也不能使用普通的for循环遍历 是一个无序的集合,存储元素和取出元素的顺序有可能不一致 底层是一个哈希表结构(查询的速度非常的快) 不重复原理元素唯一性的方式依赖于：hashCode与equals方法。 hashCode方法可以返回对象的哈希值（int类型）。 下图讲解了Set对象存储不会重复的原因： 存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(\"于谦\", 43); stuSet.add(stu); stuSet.add(new Student(\"郭德纲\", 44)); stuSet.add(new Student(\"于谦\", 43)); stuSet.add(new Student(\"郭麒麟\", 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] LinkedHashSetLinkedHashSet是HashSet下面的一个子类。 底层是一个哈希表(数组+链表/红黑树)+链表:多了一条链表(记录元素的存储顺序),保证元素有序 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果： bbb aaa abc bbc 可变参数作用：如果传参的时候只能确定参数的类型，不能确定参数的个数（比如1~n个数相加，n不确定），可以使用可变参数。 格式： 1234修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;//可变参数的特殊(终极)写法public static void method(Object...obj)&#123; &#125; 使用 123456789101112131415public class ChangeArgs &#123; public static void main(String[] args) &#123; // 随便输入几个数相加 6 7 2 12 2121 int sum = getSum(6, 7, 2, 12, 2121); System.out.println(sum); &#125; //可变参数写法 public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; 注意： 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 传递的参数个数，可以是0个(不传递)。 CollectionsaddAll方法和shuffke方法public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) addAll方法：往集合中一次性添加多个元素。 public static void shuffle(List&lt;?&gt; list) shuffke：打乱集合元素顺序。 使用 1234567891011121314public class Demo01Collections &#123; public static void main(String[] args) &#123; // 创建ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 Collections.addAll(list,\"a\",\"b\",\"c\",\"d\",\"e\"); System.out.println(list);//[a, b, c, d, e] //public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 Collections.shuffle(list); System.out.println(list); // [c, b, a, e, d] &#125;&#125; sort方法1public static &lt;T&gt; void sort(List&lt;T&gt; list) 作用：将集合中元素按照指定规则排序。 非自定义类型对于非自定义类型的集合，可以直接使用。 1234567891011121314public class Demo01Collections &#123; public static void main(String[] args) &#123; // 创建ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //往集合中添加一些元素。 Collections.addAll(list,\"c\",\"b\",\"a\",\"e\",\"d\"); System.out.println(list); // [c, b, a, e, d] //public static &lt;T&gt; void sort(List&lt;T&gt; list) 给集合排序 Collections.shuffle(list); System.out.println(list); // [a, b, c, d, e] &#125;&#125; 自定义类型对于自定义类型的集合，自定义的类需要连接Comparable接口，泛型为类名，并重写compareTo方法 1234567891011121314public class 类名 implements Comparable&lt;类名&gt;&#123; private String name; private int age; // 省略了构造方法和getter/setter方法 //重写排序的规则 @Override public int compareTo(类名 o) &#123; //return 0;//认为元素都是相同的 //自定义比较的规则,比较两个人的年龄(this,参数Person) //return this.getAge() - o.getAge();//年龄升序排序 return o.getAge() - this.getAge();//年龄降序排序 &#125;&#125; sort方法2public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) 作用：将集合中元素按照指定规则排序。 使用 下面以Integer举例，其他类型（包括自定义，自定义o1和o2后指定具体变量）类似。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo03Sort &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list01 = new ArrayList&lt;&gt;(); list01.add(1); list01.add(3); list01.add(2); System.out.println(list01);//[1, 3, 2] Collections.sort(list01, new Comparator&lt;Integer&gt;() &#123; //重写比较的规则 @Override public int compare(Integer o1, Integer o2) &#123; //return o1-o2;//升序 return o2-o1;//降序 &#125; &#125;); System.out.println(list01); // [3, 2, 1] // 自定义类型 /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 return o1.getAge()-o2.getAge(); &#125; &#125;);*/ //扩展:了解 /*Collections.sort(list02, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; //按照年龄升序排序 int result = o1.getAge()-o2.getAge(); //如果两个人年龄相同,再使用姓名的第一个字比较 if(result==0)&#123; result = o1.getName().charAt(0)-o2.getName().charAt(0); &#125; return result; &#125; &#125;);*/ &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记9——Collection、泛型","slug":"Java学习日记9——Collection、泛型","date":"2020-07-12T04:57:17.924Z","updated":"2020-07-12T13:48:56.808Z","comments":true,"path":"2020/07/12/Java学习日记9——Collection、泛型/","link":"","permalink":"http://yoursite.com/2020/07/12/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B09%E2%80%94%E2%80%94Collection%E3%80%81%E6%B3%9B%E5%9E%8B/","excerpt":"Java学习每一天","text":"Java学习每一天 Collection集合橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。在Collection接口定义着单列集合框架中最最共性的内容。 创建方法：Collection是接口，使用多态的写法创建对象。 12// 子类以ArrayList为例Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection 常用共性方法所有单列集合的最顶层的接口,里边定义了所有单列集合共性的方法，方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Demo01Collection &#123; public static void main(String[] args) &#123; //创建集合对象,可以使用多态 //Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); System.out.println(coll);//重写了toString方法 [] /* public boolean add(E e)： 把给定的对象添加到当前集合中 。 返回值是一个boolean值,一般都返回true,所以可以不用接收 */ boolean b1 = coll.add(\"张三\"); System.out.println(\"b1:\"+b1);//b1:true System.out.println(coll);//[张三] coll.add(\"李四\"); coll.add(\"李四\"); coll.add(\"赵六\"); coll.add(\"田七\"); System.out.println(coll);//[张三, 李四, 赵六, 田七] /* public boolean remove(E e): 把给定的对象在当前集合中删除。 返回值是一个boolean值,集合中存在元素,删除元素,返回true 集合中不存在元素,删除失败,返回false */ boolean b2 = coll.remove(\"赵六\"); System.out.println(\"b2:\"+b2);//b2:true boolean b3 = coll.remove(\"赵四\"); System.out.println(\"b3:\"+b3);//b3:false System.out.println(coll);//[张三, 李四, 田七] /* public boolean contains(E e): 判断当前集合中是否包含给定的对象。 包含返回true 不包含返回false */ boolean b4 = coll.contains(\"李四\"); System.out.println(\"b4:\"+b4);//b4:true boolean b5 = coll.contains(\"赵四\"); System.out.println(\"b5:\"+b5);//b5:false //public boolean isEmpty(): 判断当前集合是否为空。 集合为空返回true,集合不为空返回false boolean b6 = coll.isEmpty(); System.out.println(\"b6:\"+b6);//b6:false //public int size(): 返回集合中元素的个数。 int size = coll.size(); System.out.println(\"size:\"+size);//size:3 //public Object[] toArray(): 把集合中的元素，存储到数组中。 Object[] arr = coll.toArray(); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //public void clear() :清空集合中所有的元素。但是不删除集合,集合还存在 coll.clear(); System.out.println(coll);//[] System.out.println(coll.isEmpty());//true &#125;&#125; 注意： 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 遍历集合Iterator迭代器作用：用来遍历集合，Iterator对象也被称为迭代器。 创建：Iterator是接口，无法直接创建对象，Collection集合有专门获取迭代器的方法： 1234567/* public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。*/ // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); 迭代的概念：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法 public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 通过使用上面两个方法实现迭代，示例： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(\"串串星人\"); coll.add(\"吐槽星人\"); coll.add(\"汪星人\"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; 注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 使用 遍历数组 123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 遍历集合 123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add(\"小河神\"); coll.add(\"老河神\"); coll.add(\"神婆\"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; 注意：它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 泛型定义的时候先不写参数的类型，使用的时候再确定类型，可以在类或方法中预支地使用未知的类型。 注意：如果在创建对象的时候，还不将未知的类型确定具体的类型。默认类型为Object类型。 泛型的定义与使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如 1234567891011public class GenericClass&lt;E&gt; &#123; private E name; public E getName() &#123; return name; &#125; public void setName(E name) &#123; this.name = name; &#125;&#125; 使用：在创建对象的时候确定泛型 12345//创建GenericClass对象,泛型使用String类型 GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;(); gc3.setName(\"小明\"); String name1 = gc3.getName(); System.out.println(name1); 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 使用：调用方法时，确定泛型的类型 123456789101112public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 调用方法 show(\"123\"); show(666); // 定义含有泛型的方法 public &lt;E&gt; void show2(E mvp) &#123; System.out.println(mvp) &#125; &#125;&#125; 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如 123public interface GenericInterface&lt;I&gt; &#123; public abstract void method(I i);&#125; 使用 定义类时确定泛型的类型 123456public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123; @Override public void method(String s) &#123; System.out.println(s); &#125;&#125; 始终不确定泛型的类型，直到创建对象时，确定泛型的类型 123456public class GenericInterfaceImpl2&lt;I&gt; implements GenericInterface&lt;I&gt; &#123; @Override public void method(I i) &#123; System.out.println(i); &#125;&#125; 确定泛型： 1234567891011121314public class Demo04GenericInterface &#123; public static void main(String[] args) &#123; //创建GenericInterfaceImpl1对象 GenericInterfaceImpl1 gi1 = new GenericInterfaceImpl1(); gi1.method(\"字符串\"); // 字符串 //创建GenericInterfaceImpl2对象 GenericInterfaceImpl2&lt;Integer&gt; gi2 = new GenericInterfaceImpl2&lt;&gt;(); gi2.method(10); // 10 GenericInterfaceImpl2&lt;Double&gt; gi3 = new GenericInterfaceImpl2&lt;&gt;(); gi3.method(8.8); // 8.8 &#125;&#125; 泛型通配符泛型类或者接口作为方法的参数时，如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 注意：只能作为方法的参数使用 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记8——Object类、常用API","slug":"Java学习日记8——Object类、常用API","date":"2020-07-11T05:51:35.570Z","updated":"2020-07-11T12:06:53.572Z","comments":true,"path":"2020/07/11/Java学习日记8——Object类、常用API/","link":"","permalink":"http://yoursite.com/2020/07/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B08%E2%80%94%E2%80%94Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/","excerpt":"Java学习每一天","text":"Java学习每一天 Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; toString方法public String toString()：返回该对象的字符串表示。 用法：所用对象都可以直接调用，默认返回值是对象地址，字符串类型。 1String 变量名 = 对象名.toString(); 重写 如果不希望使用toString方法的默认返回对象地址值，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 equals方法public boolean equals(Object obj)：比较两个对象是否相等 用法：所有的对象都可以直接使用，默认比较的是对象地址值是否相等，返回返回boolean类型 1boolean 变量名 = 对象名.equals(); 重写： 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： Objects类的equals方法在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 用法：直接用Objects类调用，参数为两个需要比较的对象，返回值为boolean类型 1boolean 变量名 = Objects.equals(对象1, 对象2); 本质：还是使用了Object的equals方法，只是解决了空指针异常。 日期时间类Date类构造方法 无参构造 public Date() 12Date date = new Date(); System.out.println(date);// 当前时间，格式：Sun Aug 08 12:23:03 CST 2088 有参构造 public Date(long date) 1234// 参数是long类型Date date = new Date(0L); System.out.println(date);// 输入long类型参数毫秒对应时间，格式不变：Thu Jan 01 08:00:00 CST 1970 以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 提示1： 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 提示2：在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用成员方法public long getTime() 把日期对象转换成对应的时间毫秒值。 12// 参数：无参// 返回值类型：long 使用： 123Date date = new Date();long time = date.getTime(); System.out.println(time);//3742777636267 SimpleDateFormat类SimpleDateFormat类是抽象类DateFormat的子类 构造方法构造方法的参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则 常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 12// 对应的日期格式如：2018-01-16 15:06:38SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); 常用成员方法format方法作用：format方法配合构造方法，把时间对象转换成指定格式的字符串。 用法 12345678910/* 参数类型：Date对象; 返回值类型：String; 使用方法：String 变量名 = SimpleDateFormat对象.format(Date对象)*/ Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 parse方法作用：与format方法相反，把指定格式的字符串转换成时间对象。 用法 123456789/* 参数类型：String; 返回值类型：Date对象; 使用方法：Date 变量名 = SimpleDateFormat对象.format(String变量)*/ DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 Calendar类Calendar是抽象类，日历类。 创建因为Calendar为抽象类，无法直接创建对象，我们通过它的一个静态方法创建其子类对象 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 创建格式： 123// getInstance()方法创建的是子类对象，所以这里用的了多态写法// 创建出来的对象可以直接打印，打印结果是日历数据Calendar cal = Calendar.getInstance(); 静态成员变量Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） 常用成员方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 get方法public int get(int field) 作用：获取指定日历对象中字段的值 用法 123456789101112131415161718/* 参数类型：int 实际用Calendar类的静态成员变量 返回值类型 int 使用方法：int 变量名 = Calendar对象名.get(静态成员变量)*/public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; set方法public void set(int field, int value) 作用：设置日历对象中的数据 用法 123456789101112/* 参数列表：int int 两个int分别是静态成员变量和修改的值 void无返回值 使用方法：Calendar对象名.set(静态成员变量, 修改值)*/public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法public abstract void add(int field, int amount) 作用：可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。 用法 123456789101112131415/* 参数列表：int int 两个int分别是静态成员变量和指向字段增加的值 void无返回值 使用方法：Calendar对象名.add(静态成员变量, 增加值)*/public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法public Date getTime() 作用：获取日历对应的Date对象。 用法 123456789101112/* 无参数 返回值类型：Date 使用方法：Date 对象名 = Calendar对象名.getTime()*/public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 currentTimeMillis方法public static long currentTimeMillis() 作用：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 用法 1234567891011/* 无参数 返回值类型 long 使用方法：long 变量名 = System.currentTimeMillis()*/public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; arraycopy方法public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 作用：将一个数组中指定的数据拷贝到另一个数组中的指定位置。 参数列表 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 用法 1234567891011121314import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; StringBuilder类如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 字符串缓冲区,可以提高字符串的效率 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 12345678910public class StringBuilderDemo &#123; public static void main(String[] args) &#123; // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 常用成员方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法public StringBuilder append(...) 作用：把参数对应的字符串内容添加到StringBuilder中 用法 append方法具有多种重载形式，可以接收任意类型的参数。 123456789101112131415161718192021/* 任意类型 返回值类型：StringBuilder地址 所以不用写接收接收，且可以使用链式编程 使用方法：StringBuilder对象名.append(任意参数);*/public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); // builder:helloworldtrue100 &#125;&#125; StringBuilder和String相互转换 String转StringBuilder: 可以使用StringBuilder的有参构造方法 12StringBuilder sb2 = new StringBuilder(\"itcast\");System.out.println(sb2); // itcast 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 StringBuilder转String: 可以使用StringBuilder中的toString方法 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 包装类如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱与拆箱用Integer举例： 装箱：基本数值—-&gt;包装对象 1234// 法一：使用构造函数函数Integer i = new Integer(4);// 法二：使用包装类中的valueOf方法Integer iii = Integer.valueOf(4); 拆箱：包装对象—-&gt;基本数值 123// 使用包装类中的intValue方法Integer i = new Integer(4);int num = i.intValue(); 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串之间的转换基本类型—-&gt;String 基本类型转换String总共有三种方式 123456789// 法一：直接加上\"\"。（最常用）int i1 = 100;String s1 = i1 + \"\";// 法二：使用包装类的静态方法toString(参数)。String s2 = Integer.toString(100);// 法三：String类的静态方法valueOf(参数)。String s3 = String.valueOf(100); String—-&gt;基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意：如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记7——final、权限、内部类","slug":"Java学习日记7——final、权限、内部类","date":"2020-07-10T13:39:53.321Z","updated":"2020-07-10T15:02:36.416Z","comments":true,"path":"2020/07/10/Java学习日记7——final、权限、内部类/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07%E2%80%94%E2%80%94final%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"Java学习每一天","text":"Java学习每一天 final关键字final关键字代表最终、不可改变的。 注意事项：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 final修饰类含义：当前这个类不能有任何的子类。（太监类）。 格式： 123public final class 类名称 &#123; // ...&#125; final修饰方法含义：这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; final修饰局部变量含义：变量经过一次赋值后，这个变量就不能进行更改。 格式： 1final 数据类型 变量名; final修饰成员变量含义：变量创建时赋值后，这个变量就不能进行更改。 格式： 12修饰符 final 数据类型 变量名 = 值;// 或不直接赋值，通过构造方法赋值 注意： 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 权限1234567891011/*变量使用权限Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private同一个类（我自己） YES YES YES YES同一个包（我邻居） YES YES YES NO不同包子类（我儿子） YES YES NO NO不同包非子类（陌生人） YES NO NO NO注意事项：(default)并不是关键字“default”，而是根本不写。 */ 内部类成员内部类直接定义在一个类内部的类叫做成员内部类。 格式： 123456修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意：内用外，随意访问；外用内，需要内部类对象。 使用方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 1外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 重名： 12345678910111213141516171819// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 注意：局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 使用方法：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 权限： 123456小节一下类的权限修饰符：public &gt; protected &gt; (default) &gt; private定义一个类的时候，权限修饰符规则：1. 外部类：public / (default)2. 成员内部类：public / protected / (default) / private3. 局部内部类：什么都不能写 匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 类和接口的使用类作为成员变量类型原理：实际上类创建的对象做成员变量 举例： 创建武器类Weapon 12345678910111213141516171819public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125; 创建英雄类Hero 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 创建Main 123456789101112131415161718public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"多兰剑\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 接口作为成员变量类型原理：多态写法，实际上时用多态写法创建的对象做成员变量、返回值、参数。 举例： 创建技能接口Skill 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 实现技能接口SkillImpl 123456public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125; 创建英雄类Hero 123456789101112131415161718192021222324252627282930313233343536public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; // 接口作为返回值 return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 创建Main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记6——接口、多态","slug":"Java学习日记6——接口、多态","date":"2020-07-10T06:35:42.215Z","updated":"2020-07-10T08:56:12.966Z","comments":true,"path":"2020/07/10/Java学习日记6——接口、多态/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B06%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/","excerpt":"Java学习每一天","text":"Java学习每一天 接口接口的创建使用创建接口 创建格式跟创建类相似，把public class 类名 换成 public interface 接口名。 在任何版本的Java中，接口都能定义抽象方法。 注意：接口是没有静态代码块或者构造方法的。 创建举例 12345678910111213141516171819202122232425262728/** 接口* 把public class 类名 换成 public interface 接口名** 在任何版本的Java中，接口都能定义抽象方法。* 格式：* public abstract 返回值类型 方法名称(参数列表);** 注意事项：* 1. 接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract* 2. 这两个关键字修饰符，可以选择性的省略。* 3. 方法的三要素，可以随意定义。* */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbstract1(); // 这也是抽象方法 abstract void methodAbstract2(); // 这也是抽象方法 public void methodAbstract3(); // 这也是抽象方法 void methodAbstract4();&#125; 实现类 接口不能直接使用，必须有一个实现类来“实现”接口。 实现类创建格式：public class 实现类名称 implements 接口名称 { // …} 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，如果只是部分重写，那么这个类必须是抽象类。 实现上面接口 123456789101112131415161718192021public class MyInterfaceAbstractImpl implements MyInterfaceAbstract&#123; @Override public void methodAbstract1() &#123; System.out.println(\"这是第一个抽象方法\"); &#125; @Override public void methodAbstract2() &#123; System.out.println(\"这是第二个抽象方法\"); &#125; @Override public void methodAbstract3() &#123; System.out.println(\"这是第三个抽象方法\"); &#125; @Override public void methodAbstract4() &#123; System.out.println(\"这是第四个抽象方法\"); &#125;&#125; 使用举例12345678910111213141516171819202122/** 接口使用步骤：* 1. 接口不能直接使用，必须有一个“实现类”来“实现”接口。* 格式：* public class 实现类名称 implements 接口名称 &#123;* // ...* &#125;* 2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。* 实现：去掉abstract关键字，加上方法体大括号。* 3. 创建实现类的对象，进行使用。** 注意事项：* 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。* */public class Demo01Interface &#123; public static void main(String[] args) &#123; MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbstract1(); // 这是第一个抽象方法 impl.methodAbstract2(); // 这是第二个抽象方法 &#125;&#125; default默认方法从Java 8开始，接口里允许定义默认方法。 作用：因为接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，所以如果给接口升级（添加新的抽象方法），那么已经写好的实现类都要修改，为了防止这样的麻烦，新添加的方法用默认方法，已经写好的实现类就可以直接继承了。 创建格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：可以直接用实现类的对象调用。 static静态方法从Java 8开始，接口当中允许定义静态方法 创建格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：通过接口名称，直接调用其中的静态方法。 private私有方法从Java 9开始，接口当中允许定义私有方法。 只能内部使用，不能调用； 作用：接口内的默认方法或静态方法中可能会有重复代码，如果定义新的默认方法或静态代码来减少重复代码，会导致可调用方法增多，可以通过使用私有方法，减少重复代码，又不会增加可调用方法。 私有方法用法举例： 下面创建一个接口，减少代码重复，但不增加可调用方法。 123456789101112131415161718public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 成员变量【常量】接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。 创建格式： 1public static final 数据类型 常量名称 = 数据值; 调用格式： 1接口名.常量名； 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 多接口 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 格式： 123public class 实现类 implements 接口1, 接口2 &#123; // 覆盖重写所有抽象方法&#125; 重名： 多继承可能会出现重名问题。 抽象方法重名 在实现类中只需要覆盖重写一次即可。 默认方法重名 实现类一定要对冲突的默认方法进行覆盖重写。 父类中方法与默认方法重名 会优先用父类当中的方法。 小结 多态代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式1234格式：父类名称 对象名 = new 子类名称();或者：接口名称 对象名 = new 实现类名称(); 调用规则口诀： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边。 举例： 123456789101112131415public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 // 编译看左边，写出obj.method();，父类有method()方法，编译不报错。 // 运行看右边，在子类找method()方法，找到直接执行子类中的method方法，找不到向上找。 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 向上转型对象的向上转型，就是：父类引用指向之类对象。 向下转型向上转型一定是安全的，没有问题的，正确的。 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 含义：将父类对象，【还原】成本来的子类对象 格式： 12// 类似基本数据类型的强转 int a = (int) 10.6;子类名称 对象名 = (子类名称) 父类对象; 判断：如何才能知道一个父类引用的对象，本来是什么子类？ instanceof可以用来判断对象是否原本属于该子类 12对象 instanceof 类名称// 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 判断举例： 123456789101112131415161718192021222324252627282930313233343536373839/*如何才能知道一个父类引用的对象，本来是什么子类？格式：对象 instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 */public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记5——继承、super、this、抽象类","slug":"Java学习日记5——继承、super、this、抽象类","date":"2020-07-09T13:48:16.108Z","updated":"2020-07-09T14:41:39.210Z","comments":true,"path":"2020/07/09/Java学习日记5——继承、super、this、抽象类/","link":"","permalink":"http://yoursite.com/2020/07/09/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B05%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 继承继承的用法定义员工父类Employee 12345678910/** 定义父类格式（一个普通类的定义）* 定义子类格式：public class 子类名称 extends 父类名称 &#123;&#125;* */public class Employee &#123; public void method()&#123; System.out.println(\"方法执行\"); &#125;&#125; 定义Employee类的子类Teacher 12public class Teacher extends Employee &#123;&#125; 定义Employee类的子类Assistant 12public class Assistant extends Employee &#123;&#125; 使用 1234567891011121314151617public class Demo01Extends &#123; public static void main(String[] args) &#123; // 使用父类 Employee employee = new Employee(); employee.method(); //方法执行 System.out.println(\"===========\"); // 使用子类Teacher Teacher teacher = new Teacher(); teacher.method(); //方法执行 System.out.println(\"=============\"); // 使用子类Assistant Assistant assistant = new Assistant(); assistant.method(); //方法执行 &#125;&#125; 重名变量子类新定义和父类有相同的变量名 定义父类Fu 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 定义子类Zi 1234567public class Zi extends Fu &#123; int num = 200; public void ziShow()&#123; System.out.println(num); &#125;&#125; 父类和子类有重名变量num,使用结果如下 123456789101112public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Fu fu = new Fu(); fu.fuShow(); // 100 System.out.println(\"==========\"); Zi zi = new Zi(); zi.ziShow(); // 200 // fuShow在Fu类中定义，所以使用Fu类的num zi.fuShow(); // 100 &#125;&#125; 局部变量、子类变量、父类变量重名父类 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 子类 123456789public class Zi extends Fu &#123; int num = 200; public void ziShow(int num) &#123; System.out.println(num); // 参数的num System.out.println(this.num); // 子类的num System.out.println(super.num); // 父类的num &#125;&#125; 使用结果 12345678910111213141516171819/** 变量重名问题* 局部变量 直接写变量名* 本类变量 this.变量名* 父类变量 super.变量名* */public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.ziShow(300); &#125;&#125;/*运行结果：300200100*/ 方法的重写重写：子类把继承来的方法重写一遍，添加新的功能 父类 12345678910111213public class Phone &#123; public void call() &#123; System.out.println(\"打电话\"); &#125; public void send() &#123; System.out.println(\"发短信\"); &#125; public void show() &#123; System.out.println(\"显示号码\"); &#125;&#125; 子类 1234567891011public class NewPhone extends Phone&#123; // 重写标记，建议不省略 @Override public void show() &#123; // 调用父类的show方法，节省代码 super.show(); System.out.println(\"显示头像\"); System.out.println(\"显示姓名\"); &#125;&#125; 使用结果 1234567891011121314151617181920212223242526public class Demo01OverRide &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); phone.call(); phone.send(); phone.show(); System.out.println(\"============\"); NewPhone newPhone = new NewPhone(); newPhone.call(); newPhone.send(); newPhone.show(); &#125;&#125;/*运行结果：打电话发短信显示号码============打电话发短信显示号码显示头像显示姓名*/ super的使用super代指父类 父类 12345public class Fu &#123; public Fu() &#123; System.out.println(\"父构造方法执行\"); &#125;&#125; 子类 1234567public class Zi extends Fu &#123; public Zi()&#123; // 这里自动补充super(); // super(); System.out.println(\"子构造方法执行\"); &#125;&#125; 使用及super注意 123456789101112131415161718/** 1. 子类构造方法当中有一个默认隐含的“supper()”调用，所以一定先调用的父类构造，后执行子类构造。* 2. 子类构造可以通过super关键字来调用父类重载构造。* 3. super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。* 总结：* 子类必须调用父类构造方法，不写则赠送super()，写了则用写的指定的super调用，super只能有一个，还必须是第一个。* */public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125;/*运行结果：父构造方法执行子构造方法执行*/ 抽象方法和抽象类抽象方法：就是加上abstract关键字，然后去掉大括号。抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可。 父类 123public abstract class Animal &#123; public abstract void eat();&#125; 子类 123456public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 使用结果 1234567891011121314151617/** 抽象方法：就是加上abstract关键字，然后去掉大括号* 抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可** 如何使用抽象类和抽象方法：* 1. 不能直接创建new抽象类对象。* 2. 必须用一个子类来继承抽象父类。* 3. 子类必须覆盖重写抽象父类当中所有的抽象方法。* 4. 创建子类对象进行使用。* */public class Demo01Abstract &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.eat(); // 猫吃鱼 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记4——String类、static、Arrays类、Math类","slug":"Java学习日记4——String类、static、Arrays类、Math类","date":"2020-07-08T13:19:58.449Z","updated":"2020-07-09T07:44:08.654Z","comments":true,"path":"2020/07/08/Java学习日记4——String类、static、Arrays类、Math类/","link":"","permalink":"http://yoursite.com/2020/07/08/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B04%E2%80%94%E2%80%94String%E7%B1%BB%E3%80%81static%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 String类String类的创建 创建方法 12345678910111213141516171819202122232425262728293031323334/*String类String类的3+1种创建方法 1. 使用空参构造 String 对象名 = new String(); 2. 根据字符数组创建字符串 String 对象名 = new String(char[] array); 3. 根据字节数组创建字符串 String 对象名 = new String(byte[] array); 4. 直接创建 String str = \"Hello\";*/public class Demo01String &#123; public static void main(String[] args) &#123; // 使用空参构造 String str1 = new String(); System.out.println(\"第一个字符串：\" + str1); // 第一个字符串： // 根据字符数组创建字符串 char[] charArray = &#123;'A', 'B', 'C'&#125;; String str2 = new String(charArray); System.out.println(\"第二个字符串：\" + str2); // 第二个字符串：ABC // 根据字节数组创建字符串 byte[] byteArray = &#123;97, 98, 99&#125;; String str3 = new String(byteArray); System.out.println(\"第三个字符串：\" + str3); // 第三个字符串：abc // 直接创建 String str4 = \"Hello!\"; System.out.println(str4); // Hello! &#125;&#125; 字符串常量池 1234567891011121314// 字符串常量池：程序中直接写的引号字符串，就在字符串常量池中// 对引用类型来说，==是进行【地址值】的比较public class Demo02StringPool &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false &#125;&#125; String类成员方法字符串比较1234567891011121314151617181920212223242526272829/*字符串比较1. public boolean equals(Object obj) 区分大小写 用法：对象名.equals(对象名);2. public boolean equalsIgnoreCase(String str); 不区分大小写 用法：对象名.equalsIgnoreCase(对象名);*/public class Demo01StringEquals &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1.equals(str2)); // true System.out.println(str2.equals(str3)); // true String str4 = null;// System.out.println(str4.equals(\"abc\")); // 报错！ System.out.println(str2.equals(\"abc\")); // true 不推荐 System.out.println(\"abc\".equals(str3)); // true 推荐 String str5 = \"Java\"; String str6 = \"java\"; System.out.println(str5.equals(str6)); // false 区分大小写 System.out.println(str5.equalsIgnoreCase(str6)); // true 不区分大小写 &#125;&#125; 字符串——获取长度、指定位置字符、字符串位置、拼接12345678910111213141516171819202122232425262728/** String中与获取相关的方法有** public int length() 获取字符串长度* public String concat(String str) 拼接字符串，返回新的字符串* public char charAt(int index) 获取字符串指定位置的字符（从零开始数）* public int indexOf(String str) 获取参数字符串在本字符串中首次出现的位置，如果没有返回-1* */public class Demo02StringGet &#123; public static void main(String[] args) &#123; // 获取字符串长度 int length = \"hello\".length(); System.out.println(length); // 5 // 拼接字符串 String str1 = \"Hello\".concat(\" World\"); System.out.println(str1); // Hello World // 获取字符串指定位置字符 char ch = str1.charAt(2); System.out.println(ch); // 1 // 获取字符串首次出现的位置 int index = str1.indexOf(\"lo\"); System.out.println(index); // 3 &#125;&#125; 字符串截取1234567891011121314151617181920/** 字符串的截取方法** public String substring(int index) 从参数位置开始一直截取到末尾* public String substring(int begin, int end) 截取begin到end之间的字符串* 备注：[begin,end),包括左边，不包括右边* */public class Demo03Substring &#123; public static void main(String[] args) &#123; // 截取到末尾 String str1 = \"Hello World\"; String str2 = str1.substring(6); System.out.println(str2); // 指定开始结束位置 String str3 = str1.substring(4,8); System.out.println(str3); &#125;&#125; 字符串转数组、替换字符串123456789101112131415161718192021222324252627282930/** String中与转换相关的方法有** public char[] toCharArray() 将字符串拆分成字符数组返回* public byte[] getBytes() 获取当前字符串底层的字节数组* public String replace(CharSequence orderString, CharSequence newString) 替换字符串* */import java.util.Arrays;public class Demo04StringConvert &#123; public static void main(String[] args) &#123; // 转换成字符数组 char[] chars = \"Hello\".toCharArray(); System.out.println(Arrays.toString(chars)); // [H, e, l, l, o] System.out.println(chars.length); // 5 System.out.println(\"=========================\"); // 转换成字节数组 byte[] bytes = \"abc\".getBytes(); System.out.println(Arrays.toString(bytes)); // [97, 98, 99] System.out.println(bytes.length); // 3 System.out.println(\"==========================\"); // 替换字符串 String str1 = \"How do you do?\"; String str2 = str1.replace('o','*'); System.out.println(str2); // H*w d* y*u d*? &#125;&#125; 字符串分割12345678910111213141516171819202122232425/** 字符串分割方法* public String[] split(String regex) 按照参数的规则，把字符串分割成若干段** 注意事项：* split方法的参数其实是一个“正则表达式”* 如果按照英文句点“.”进行分割，必须写成“\\\\.”* */public class Demo05StringSplit &#123; public static void main(String[] args) &#123; String str1 = \"aaa,bbb,ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"======================\"); String str2 = \"jjj.ddd.ggg\"; strArray = str2.split(\"\\\\.\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; &#125;&#125; Static静态静态的使用先定义含有静态成员变量和静态成员方法的类Student 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private int id; private String name; private int age; //静态成员变量 static String room; static int idCounter = 0; //静态成员方法 public static void show()&#123; System.out.println(\"静态成员方法\"); &#125; // 构造方法 public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public Student() &#123; &#125; // getter/setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 使用Student类 123456789101112131415161718192021// static静态成员变量中的数据共享，即该变量属于类，而不属于对象/** 1. 静态不能访问非静态* 2. 推荐静态成员变量个静态成员方法直接用类调用* 3. 静态成员方法不能使用this* */public class demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student(\"郭靖\",19); Student.room = \"黄埔军校\"; System.out.println(\"学号：\"+one.getId()+\"，姓名：\"+one.getName()+\"，年龄：\"+one.getAge()+\"，教室：\"+Student.room); // 教室共享，学号自增 Student two = new Student(\"黄蓉\",18); System.out.println(\"学号：\"+two.getId()+\"，姓名：\"+two.getName()+\"，年龄：\"+two.getAge()+\"，教室：\"+Student.room); // 调用静态成员方法 Student.show(); // 静态成员方法 &#125;&#125; 静态代码块先定义一个含有静态代码块的类Person 12345678910public class Person &#123; // 静态代码块 static &#123; System.out.println(\"这是静态代码块\"); &#125; // 构造方法 public Person()&#123; System.out.println(\"这是构造方法\"); &#125;&#125; 使用Person类 1234567891011121314151617/** 静态代码块：static&#123;&#125;* 1. 静态代码块只在第一次使用类的时候执行一次* 2. 静态代码块先执行* 3. 典型用途：用于一次性的对静态变量赋值* */public class demo03Static &#123; public static void main(String[] args) &#123; Person one = new Person(); /* * 运行结果： * 这是静态代码块 * 这是构造方法 * */ &#125;&#125; Arrays类12345678910111213141516171819202122232425/* * java.util.Arrays是一个与数组相关的工具类 * * public static String toString(数组) 将参数数组变成字符串，格式为“[元素1,元素2,元素3.。。。]” * public static void sort(数组) 按照默认升序（从小到大）对数组排列 * 备注：1. 数字升序排列， * 2. 字符串按字母升序排列 * 3. 如果是自定义类型，那么自定义类型需要有Comparable或者Comparator接口的支持 * */import java.util.Arrays;public class Demo01Arrays &#123; public static void main(String[] args) &#123; int[] intArray = &#123;10, 20, 30&#125;; // 将数组变成字符串 String intStr = Arrays.toString(intArray); System.out.println(intStr); // [10, 20, 30] // 对数组排序 int[] array1 = &#123;2, 1, 3, 10, 6&#125;; Arrays.sort(array1); System.out.println(Arrays.toString(array1)); // [1, 2, 3, 6, 10] &#125;&#125; Math类12345678910111213141516171819202122232425262728293031/** Math是数学工具类** public static double abs(double num) 获取绝对值* public static double ceil(double num) 向上取整* public static double floor(double num) 向下取整* public static long round(double num) 四舍五入* */public class Demo03Math &#123; public static void main(String[] args) &#123; // 获取绝对值 System.out.println(Math.abs(3.14)); // 3.14 System.out.println(Math.abs(-3.14)); // 3.14 System.out.println(\"==============\"); // 向上取整 System.out.println(Math.ceil(3.14)); // 4 System.out.println(Math.ceil(-3.14)); // -3 System.out.println(\"==============\"); // 向下取整 System.out.println(Math.floor(3.14)); // 3 System.out.println(Math.floor(-3.14)); // -4 System.out.println(\"==============\"); // 四舍五入 System.out.println(Math.round(3.14)); // 3 System.out.println(Math.round(-3.14)); // -3 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"HTML学习日记1——HTML新增属性","slug":"HTML学习日记1——HTML新增属性","date":"2020-05-14T03:52:04.049Z","updated":"2020-05-14T04:09:26.730Z","comments":true,"path":"2020/05/14/HTML学习日记1——HTML新增属性/","link":"","permalink":"http://yoursite.com/2020/05/14/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94HTML%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/","excerpt":"学习HTML每一天","text":"学习HTML每一天 h5新增标签新增内容： 标签 作用 header 头部标签 nav 导航栏 aside 侧边栏 article 内容标签 section 某个区域 footer 尾部标签 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;h5新增标签&lt;/title&gt; &lt;style&gt; header&#123; background-color: pink; height: 188px; width: 800px; margin: 20px auto; border-radius: 15px; &#125; nav&#123; background-color: pink; width: 800px; height: 50px; margin: 10px auto; &#125; aside&#123; width: 500px; height: 700px; background-color: skyblue; float: left; &#125; article&#123; width: 500px; height: 700px; background-color: blueviolet; float: left; &#125; footer&#123; background-color: aquamarine; width: 100%; height: 50px; &#125; section&#123; background-color: burlywood; height: 200px; width: 200px; &#125; div:after&#123; /* 清除浮动 */ clear: both; display: block; content: \"\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;头部标签&lt;/header&gt; &lt;nav&gt;导航栏标签&lt;/nav&gt; &lt;div&gt; &lt;aside&gt;侧边栏标签&lt;/aside&gt; &lt;article&gt;内容标签 &lt;section&gt;定义文档的某个区域&lt;/section&gt; &lt;/article&gt; &lt;/div&gt; &lt;footer&gt;尾部标签&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; video和audio标签video视频标签1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;video视频标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- video视频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 poster 视频封面 width 宽度 height 高度 preload 预加载 --&gt; &lt;video src=\"../../source/video/救赎.mp4\" autoplay=\"autoplay\" muted=\"muted\" controls=\"controls\" loop=\"loop\" poster=\"../../source/img/test.png\"&gt;&lt;/video&gt; &lt;/body&gt;&lt;/html&gt; audio音频标签12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;audio音频标签&lt;/title&gt; &lt;!-- video音频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 preload 预加载 --&gt; &lt;/head&gt; &lt;body&gt; &lt;audio src=\"../../source/audio/希望之花.mp3\" autoplay=\"autoplay\" controls=\"controls\" loop=\"loop\"&gt; 当前浏览器不支持audio &lt;/audio&gt; &lt;/body&gt;&lt;/html&gt; input新增表单123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"\"&gt; &lt;ul&gt; &lt;li&gt;邮箱：&lt;input type=\"email\"&gt;&lt;/li&gt; &lt;li&gt;网址：&lt;input type=\"url\"&gt;&lt;/li&gt; &lt;li&gt;日期：&lt;input type=\"date\"&gt;&lt;/li&gt; &lt;li&gt;时间：&lt;input type=\"time\"&gt;&lt;/li&gt; &lt;li&gt;数量：&lt;input type=\"number\"&gt;&lt;/li&gt; &lt;li&gt;手机号：&lt;input type=\"tel\"&gt;&lt;/li&gt; &lt;li&gt;搜索：&lt;input type=\"search\"&gt;&lt;/li&gt; &lt;li&gt;颜色：&lt;input type=\"color\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; input新增属性1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增属性&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 搜索placeholder文字格式设置 */ input::placeholder&#123; color: #8A2BE2; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;!-- 搜索框 属性 作用 required 不能为空 placeholder 框内背景文字，输入文字消失 autofocus 自动聚焦到框中 autocomplete 输入过的内容提示，默认on 注意： 设置placeholder文字格式：input::placeholder &#123;&#125; --&gt; &lt;input type=\"search\" required=\"required\" placeholder=\"搜索\" autofocus=\"autofocus\" autocomplete=\"off\" /&gt; &lt;br /&gt; &lt;!-- 添加文件表单 属性 作用 multiple 加上这个属性后，就可以一次添加多个文件了 --&gt; &lt;input type=\"file\" multiple=\"multiple\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Java学习日记3——Scanner类、Random类、ArrayList类","slug":"Java学习日记3——Scanner类、Random类、ArrayList类","date":"2020-05-13T06:42:38.515Z","updated":"2020-05-13T12:13:20.878Z","comments":true,"path":"2020/05/13/Java学习日记3——Scanner类、Random类、ArrayList类/","link":"","permalink":"http://yoursite.com/2020/05/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B03%E2%80%94%E2%80%94Scanner%E7%B1%BB%E3%80%81Random%E7%B1%BB%E3%80%81ArrayList%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 Scanner类作用：接收键盘输入的内容。 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner; // 导包语句，写在类的外面，可自动生成/* * Scanner是JDK提供的一个类，详情见API。 * * 引用类型的一般使用步骤 * 1. 导包 * 导包格式：import 包路径.类名称; * 如果要使用的目标类和当前类位于同一包下，则可以省略导包语句不写。 * java.lang包下的内容不需要导包。 * 2. 创建 * 格式：类名称 对象名 = new 类名称(); * 3. 使用 * 对象名.成员方法; * */public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 创建Scanner类的对象 // System.in代表从键盘输入 // 括号中不能为空，System.in是目前的固定写法。 Scanner sc = new Scanner(System.in); // 获取从键盘输入的数字 // sc.nextInt()方法用于获取从键盘输入的数字 int num = sc.nextInt(); System.out.println(\"从键盘输入的数字是：\" + num); // 获取从键盘输入的字符串 // sc.next()方法用于获取从键盘输入的字符串 String str = sc.next(); System.out.println(\"从键盘输入的字符串是：\" + str); /*-----注意：从键盘输入的都是字符串，不同的方法是将字符串转变成不同的类型------*/ &#125;&#125; 匿名对象简单使用匿名对象先创建一个Person类备用 123456789// 定义一个Person类public class Person &#123; String name; public void show() &#123; System.out.println(\"我叫：\" + name); &#125;&#125; 简单使用 1234567891011121314151617/** 匿名对象* 创建格式：new 类名();* 注意事项：匿名对象只能使用唯一的一次。* 使用建议：确定只是用一次，可以使用匿名对象。* */public class Demo01Anonymous &#123; public static void main(String[] args) &#123; Person one = new Person(); one.name = \"高圆圆\"; one.show(); System.out.println(\"===============\"); new Person().name = \"一方通行\"; new Person().show(); // 我叫：null &#125;&#125; 匿名对象与方法匿名对象做参数和返回值 123456789101112131415161718192021222324252627282930313233// 匿名对象的使用举例import java.util.Scanner;public class Demo02Anonymous &#123; public static void main(String[] args) &#123; // 直接传值 System.out.println(\"输入第一个数字：\"); int num1 = new Scanner(System.in).nextInt(); System.out.println(\"输入的数字是：\" + num1); // 匿名对象做方法的参数 methodParam(new Scanner(System.in)); // 匿名对象做返回值 Scanner sc = methodReturn(); System.out.println(\"输入第三个数字：\"); int num3 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num3); &#125; // 匿名对象参数方法 public static void methodParam(Scanner sc) &#123; System.out.println(\"输入第二个数字：\"); int num2 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num2); &#125; // 匿名对象做返回值方法 public static Scanner methodReturn() &#123; return new Scanner(System.in); &#125;&#125; Random类作用：产生随机数 123456789101112131415161718192021222324252627282930313233/* * 使用Random类 * 1. 导包 * 2. 创建 * 格式：Random 对象名 = new Random(); * 3. 使用 * 格式：int 变量名 = 对象名.nextInt(); * 括号内没有参数：返回在int范围内区随机数。 * 括号内有一个参数n：返回区间[0,n)上的一个随机数（可以通过加减数字控制区间）。 * */import java.util.Random;public class Demo01Random &#123; public static void main(String[] args) &#123; // 不设定范围 Random r = new Random(); int num = r.nextInt(); System.out.println(\"得到随机数：\" + num); // 设定范围 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(10); System.out.println(\"区间[0，10)上的随机数：\" + num); &#125; // 控制区间 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(5) + 1; System.out.println(\"区间[1,6)上的随机数：\" + num); &#125; &#125;&#125; ArrayList类作用：代替对象数组存在 对象数组创建Person标准类 1234567891011121314151617181920212223242526272829public class Person &#123; String name; // 姓名 int age; // 年龄 // 构造方法 public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // setter/getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 创建使用对象数组 123456789101112131415161718192021// 对象数组// 创建格式：类名[] 对象名 = new 类名[元素个数]public class Demo01Array &#123; public static void main(String[] args) &#123; Person[] array = new Person[3]; // 创建对象数组 Person one = new Person(\"迪丽热巴\",18); Person two = new Person(\"古力娜扎\",28); Person three = new Person(\"马尔扎哈\",38); array[0] = one; array[1] = two; array[2] = three; System.out.println(array[0]); // 地址值 System.out.println(array[1]); // 地址值 System.out.println(array[2]); // 地址值 System.out.println(array[1].name); // 古力娜扎 &#125;&#125; ArrayList类初识ArrayList12345678910111213141516171819202122232425262728/** ArrayList类* ArrayList集合的长度是可以随时变化的* 格式：ArrayList&lt;E&gt; 对象名 = new ArrayList&lt;&gt;();* 其中&lt;E&gt;代表泛型* 泛型：也就是装在集合中的所有元素，全都是是统一类型。* 注意：* 泛型只能是引用类型，不能是基本类型。* 对于ArrayList集合来说，直接打印得到的不是地址值，而是内容* 如果为空，则打印结果为 []* */import java.util.ArrayList;public class Demo02ArrayList &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] list.add(\"赵丽颖\"); System.out.println(list); // [赵丽颖] list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] &#125;&#125; ArrayList的常用方法1234567891011121314151617181920212223242526272829303132333435363738394041/*ArrayList中常用的方法。public boolean add(E e); 向集合当中添加元素，参数的类型和泛型一致，返回值代表添加是否成功。public E get(int index); 从集合中获取元素，参数是索引编号，返回值就是对应位置的元素，索引值从0开始数。public E remove(int index); 从集合当中删除元素，参数是索引编号，返回值就是所被删除的元素，索引值从0开始数。public int size(); 获取集合中元素的个数。*/import java.util.ArrayList;public class Demo03ArrayListMethod &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 添加元素 list.add(\"赵丽颖\"); list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] // 获取元素 String name = list.get(2); System.out.println(\"获取到的人名：\" + name); // 获取到的人名：古力娜扎 // 删除元素 String remove = list.remove(3); System.out.println(\"被删除的人是：\" + remove); // 被删除的人是：玛尔扎哈 System.out.println(list); //[赵丽颖, 迪丽热巴, 古力娜扎] // 获取元素个数 int size = list.size(); System.out.println(size); // 3 &#125;&#125; 包装类123456789101112131415161718192021222324252627/*包装类泛型只能是引用类型，不能是基本类型。为了集合存放基本类型，可以使用包装类。基本类型 包装类（引用类型，包装类位于java.lang包下）byte Byteshort Shortint Integer 【特殊】long Longfloat Floatdouble Doublechar Character 【特殊】boolean Boolean*/import java.util.ArrayList;public class Demo05ArrayListBasic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(100); list.add(200); list.add(300); int num = list.get(1); System.out.println(num); // 200 &#125;&#125; 集合与方法1234567891011121314151617181920212223242526272829303132333435363738// 集合做方法的参数和返回值// 用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。import java.util.ArrayList;import java.util.Random;public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; Random r = new Random(); ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); // 在大集合中放入20个随机数字 for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(20) + 1; // 1~20的随机数 bigList.add(num); &#125; // 调用自定义方法，定义，打印小集合 ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(smallList); &#125; // 定义方法 // 参数和返回值都是集合 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); // 筛选偶数元素，放入小集合 for (int i = 0; i &lt; bigList.size(); i++) &#123; int num; if (bigList.get(i) % 2 == 0) &#123; num = bigList.get(i); smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记2——类与对象","slug":"Java学习日记2——类与对象","date":"2020-05-11T08:07:58.285Z","updated":"2020-05-11T09:35:56.160Z","comments":true,"path":"2020/05/11/Java学习日记2——类与对象/","link":"","permalink":"http://yoursite.com/2020/05/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B02%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"学习Java每一天","text":"学习Java每一天 JDK提供的Arrays类中的toString方法12345678910111213// 使用面向对象的方法打印数组arrayimport java.util.Arrays; // 这行代码是自动生成的，不用管。public class Demo01PrintArray &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; // JDK给我们提供的Arrays类中，有一个toString方法 // 能把数组变成我们想要的字符串 System.out.println(Arrays.toString(array)); &#125;&#125; 类与对象的定义和使用类的定义：类中有两个组成部分：成员变量，成员方法。 12345678910111213141516171819202122232425262728293031/** 类与对象：* 类是对象的模板，对象是类的实体。** 定义一个Studnet类，类有两部分组成* 成员变量：* String name; // 名字* int age; // 年龄* 成员方法：* public void eat()&#123;&#125;; // 吃饭* public void sleep() &#123;&#125;; // 睡觉* public void study() &#123;&#125;; // 学习** 注意事项：* 1. 成员变量直接定义在类当中，在方法外边。* 2. 成员方法不要写static关键字。* */public class Student &#123; String name; int age; public void eat() &#123; System.out.println(\"吃饭饭！\"); &#125;; public void sleep() &#123; System.out.println(\"睡觉觉！\"); &#125;; public void study() &#123; System.out.println(\"学习！\"); &#125;;&#125; 类的使用类的基本使用使用上面定义的类，学习类的基本使用方法 1234567891011121314151617181920212223242526272829303132/** 类的使用：* 1. 导包：也就是指出所需要的类在什么位置。* 导包格式：import 包名称.类名称* 例： import cn.itcast.day06.demo01.Student;* 注意；如果和当前类属于同一个包，则导包语句可以省略不写。* 2. 创建对象：* 类名称 对象名 = new 类名称();* 例：Student stu = new Student();* 3. 使用：* 使用成员变量：对象名.成员变量名。* 使用成员方法：对象名 成员方法名(参数)。* */public class Demo02Student &#123; public static void main(String[] args) &#123; // 1.导包 // 位于同一个包，导包可以省略 // 2.创建 Student stu = new Student(); // 3.使用 // 使用成员变量 System.out.println(stu.name); // null System.out.println(stu.age); // 0 // 使用成员方法 stu.eat(); // 吃饭饭 stu.sleep(); // 睡觉觉 stu.study(); // 学习 &#125;&#125; 对象与方法先定义一个Phone类 123456789101112131415// 定义一个手机类public class Phone &#123; String brand; // 品牌 double price; // 价格 String color; // 颜色 public void call(String who) &#123; System.out.println(\"给\" + who + \"打电话\"); &#125; public void sendMessage() &#123; System.out.println(\"群发短信\"); &#125;&#125; 下面使用上面定义的Phone类 对象可以作为方法的参数 1234567891011121314151617181920// 对象作为方法的参数// 格式：public static 返回值类型 方法名(类名 参数名)&#123;&#125;;// 参数接收到的是对象的地址值public class Demo02PhoneParam &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; method(one); &#125; // 定义对象为参数的方法 public static void method(Phone one)&#123; System.out.println(one.brand); System.out.println(one.price); System.out.println(one.color); &#125;&#125; 对象可以作为方法的返回值 123456789101112131415161718192021// 对象作为方法的返回值// 格式：public static 类名 方法名(参数类型 参数名)&#123;&#125;// 返回值实际上是对象的地址public class Demo03PhoneReturn &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand); System.out.println(two.price); System.out.println(two.color); &#125; // 定义返回值为对象的方法 public static Phone getPhone() &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 局部变量和全局变量12345678910111213141516171819202122232425262728293031/** 局部变量和全局变量的不同* 1. 定义的位置不同【重点】* 局部变量：在方法内定义。* 全局变量：载方法外部，直接在类中定义。* 2. 作用范围不同【重点】* 局部变量：只有在方法当中可以用。* 全局变量：整个类中都可以使用。* 3. 默认值不同【重点】* 局部变量：没有默认值。* 全局变量：有默认值。* 4. 内存的位置不同【了解】* 局部变量：位于栈内存。* 全局变量：位于堆内存。* 5. 生命周期不同【了解】* 局部变量：随着方法进栈而诞生，随着方法出栈而消失。* 全局变量：随着对象创建而诞生，随着对象被垃圾回收而消失。* */public class Demo01VariableDifference &#123; String name; public void methodA()&#123; int num1; int num2 = 20; System.out.println(name); // 全局变量可以在整个类中使用，且有默认值。// System.out.println(num1); // 错误！num没有默认值。 &#125; public void methodB()&#123;// System.out.println(num2); // 错误！局部变量只能在定义变量的方法内使用。 &#125;&#125; 面对对象——封装面对对象有三大特征：封装，继承，多态。 封装在Java中体现 方法就是一种封装 123456789101112131415public class Demo02Method &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 50, 6000&#125;; System.out.println(getMax(array)); &#125; // 定义一个方法，返回一个数组的最大值。 public static int getMax(int[] array) &#123; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = max &gt; array[i] ? max : array[i]; &#125; return max; &#125;&#125; 关键字private也是一种封装 定义Person类，并将age变量加上private。并学习setter/getter方法 1234567891011121314151617181920212223242526/** 定义Person类，并将age变量加上private。** private效果：可是使加private的变量可以在类中被访问，但无法在类外被直接访问。* 间接访问private变量的方法：添加一对setter方法和getter方法。* 方法名：setter方法和getter方法的方法名格式必须为setXxx和getXxx* 作用：可以防止错误和恶意修改*/public class Person &#123; String name; // 名字 private int age; // 年龄 public void show()&#123; System.out.println(\"姓名：\"+name+\"，年龄：\"+age); &#125; public void setAge(int a)&#123; if(a&gt;=0&amp;&amp;a&lt;=100)&#123; age = a; &#125; else &#123; System.out.println(\"输入数据错误！\"); &#125; &#125; public int getAge()&#123; return age; &#125;&#125; 使用Person类，查看private的效果 1234567891011121314public class Demo03Person &#123; public static void main(String[] args) &#123; Person person = new Person(); person.show(); System.out.println(\"=================\"); person.name = \"赵丽颖\";// person.age = 18; // 错误写法！age有private修饰，无法直接访问。 person.setAge(-20); // 年龄不可以为负数，修改失败！ person.show(); System.out.println(\"=====================\"); person.setAge(18); // 修改成功。 person.show(); &#125;&#125; 注意：boolean类型的成员看变量的getter方法的方法名为isXxx。 this关键字this关键字用于解决成员方法的参数和成员变量重名的问题，下面使用this关键字定义一个Person类。 123456789101112// 定义Person类// 当成员方法中的参数和成员变量重名时，用this关键字来区分// this代指调用方法的对象public class Person &#123; String name; // 姓名 public void sayHello(String name)&#123; System.out.println(this); // 打印调用该方法的对象的地址值 System.out.println(name+\"，你好，我是\"+this.name); &#125;&#125; 可见，this在这里代指调用方法的对象。 构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243/** 构造方法：专门用来创建对象的方法（创建对象时，new后面的那个方法）。* 格式：class 类名(参数类型 参数名)&#123;* 方法体;* &#125;* 注意事项；* 1. 构造方法的名称必须和类名称一样（包括大小写）。* 2. 构造方法不写返回值类型。* 3. 不写构造方法编译器会默认赠送一个没有参数，没有方法体的构造方法。* 4. 一旦编译至少一个构造方法，编译器将不再赠送。* 5. 构造方法是可以重载的。* */public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法（无参） public Student()&#123; System.out.println(\"构造方法执行啦\"); &#125; // 构造方法（全参） public Student(String name,int age)&#123; this.name = name; this.age = age; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 标准类1234567891011121314151617181920212223242526272829303132333435363738394041/** 定义一个标准类。* 标准类四个组成部分* 1. 所有成员变量都要用private关键字修饰。* 2. 为每一对成员变量编写一对getter/setter方法* 3. 编写一个无参数的构造方法。* 4. 编写一个全参数的构造方法。** 这样标准的类也叫做Java Bean* 使用Alt+Ins组合键可以生成代码。*/public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"next使用日志（扩展篇）","slug":"next使用日志（扩展篇）","date":"2020-05-04T17:49:40.577Z","updated":"2020-05-13T13:00:56.796Z","comments":true,"path":"2020/05/05/next使用日志（扩展篇）/","link":"","permalink":"http://yoursite.com/2020/05/05/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%EF%BC%88%E6%89%A9%E5%B1%95%E7%AF%87%EF%BC%89/","excerpt":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步","text":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步 添加动漫小人在博客根目录下执行命令 1npm install --save hexo-helper-live2d 执行上面代码之后，变可以选择要安装的动画了，选择参考https://huaji8.top/post/live2d-plugin-2.0/ 找到自己喜欢的动画之后，执行下面命令 1npm install live2d-widget-model-koharu 注意，上面命令最后的koharu是你选择的动画名，我这里是以koharu举例 安装完成后，要想要显示出来，还需要在站点配置文件添加下面代码 1234567891011121314151617#二次元live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu # 注意这里的koharu是上面安装的动画名字 display: position: right #在屏幕上的显示位置 width: 85 #显示宽度 height: 170 #显示高度 mobile: show: false #手机端是否显示 不想再使用这个插件的时候，可以执行下面命令卸载 1npm uninstall hexo-helper-live2d 方法来源：https://blog.csdn.net/wugenqiang/article/details/88375517 调整内容宽度因为默认内容宽度太窄，代码经常会显示不全，会生成滚动条，看起来特别不方便。 找到文件Hexo/themes/next/source/css/_custom/custom.styl 在里面添加代码 123.header&#123; width: 70%; &#125; /* 80% */.container .main-inner &#123; width: 70%; &#125; /* 80% */.content-wrap &#123; width: calc(100% - 260px); &#125; 注意百分比要一致。 方法来源1：https://github.com/iissnan/hexo-theme-next/issues/759 方法来源2：https://blog.zuiyu1818.cn/posts/NexT_codewidth.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"next使用日志（问题篇）","slug":"next使用日志","date":"2020-05-04T07:47:49.916Z","updated":"2020-05-04T17:48:26.891Z","comments":true,"path":"2020/05/04/next使用日志/","link":"","permalink":"http://yoursite.com/2020/05/04/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/","excerpt":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。","text":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。 菜单项的链接正常打开 去掉||前的空格才会生效 第一个斜杠代表博客主页的相对目录，写网址的话需要删除第一个 / 正常使用分类和标签按操作要求打开分类和标签的菜单项之后，发现这两个功能并不能使用，在博客根目录下执行代码 123hexo new page \"about\"hexo new page \"tags\"hexo new page \"categories\" 这三行代码会在博客根目录下的source目录中创建about、tags、categories三个文件夹，并分别创建index.md文件，分别修改这三个文件 1234567# title和date是自动生成的，只需要添加type即可，type引号内是文件名（不带扩展名）# title是博客显示的名字，如果不写，默认显示文件名# date是博客发表时间，如果不写，默认显示文件创建时间title: categoriesdate: 2018-03-02 12:33:16type: \"categories\" 点击日志错误显示侧栏下面的日志应该和归档有相同的效果，但是实际上点击日志只会显示错误代码，解决方法是找到themes/next/_config.yml 文件下将archives：/archives/ || archive 改成archives：/archives/ 未解决问题 点击日程表错误 点击站点地图错误 关于怎么写入内容 标签和分类都是英文","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Java学习日记1——数组","slug":"Java学习日记1——数组","date":"2020-05-03T12:17:09.305Z","updated":"2020-05-11T09:13:18.965Z","comments":true,"path":"2020/05/03/Java学习日记1——数组/","link":"","permalink":"http://yoursite.com/2020/05/03/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"学习Java每一天","text":"学习Java每一天 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+V 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标所在下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+向上箭头 移动当前代码 Shift+F6 修改所有同名字符 Alt+/ 代码提示 数组数组的初始化a. 数组的初始化分为 静态初始化 1234567// 一般的静态初始化int[] array0 = new int[]&#123;20, 30, 40&#125;; // 静态初始化的省略格式 int[] array1 = &#123; 5, 25, 35 &#125;; // 分成两步初始化，分成两步来写就不能使用省略格式了 int[] array2; array2 = new int[] &#123; 2, 3, 5 &#125;; 动态初始化 123456// 一般的动态初始化int[] array0 = new int[3];// 分成两步的动态初始化int[] array1;array1 = new int[3];System.out.println(array1); // 直接打印数组名称，得到数组对应的，内存地址哈希值 b. 初始化的默认值 1234567891011121314151617181920/** 使用动态初始化的时候，其中的元素将会自动拥有一个默认值，规则如下：* 1. 如果是整数类型，那么默认值为0；* 2. 如果是浮点类型，那么默认值为0。0* 3. 如果是字符类型，那么默认值为' \\u0000'；* 4. 如果是字符串类型，那么默认值为null；* 5. 如果是布尔类型，那么默认值为false*/public class Demo05ArrayUse &#123; public static void main(String[] args) &#123; int[] array = new int[3]; System.out.println(array); // 内存地址哈希值 System.out.println(array[0]); // 0 System.out.println(array[1]); // 0 System.out.println(array[2]); // 0 array[1] = 123; System.out.println(array[1]); // 123 &#125;&#125; 数组的错误 越界异常 123456789101112// 如果访问数组编号的时候，索引编号不存在，那么将会发生数组索引越界异常public class Demo01ArrayIndex &#123; public static void main(String[] args) &#123; int[] array = &#123; 5, 25, 35 &#125;; // 错误写法 // 不存在第三号元素，所以发生异常 System.out.println(array[3]); &#125;&#125; 空指针异常 123456789101112// 所有索引类型变量，都可以赋值为一个null值。但是代表其中什么都没有。/*数组必须进行new初始化才能使用其中的元素。如果只赋值了一个null，没有进行new创建那么就会发生：空指针异常 NullPointerException*/public class Demo02ArrayNull &#123; public static void main(String[] args) &#123; int[] array = null; System.out.println(array[0]); &#125;&#125; 数组与方法 数组作为方法的参数 12345678910111213141516171819202122/** 数组作为参数* 参数写法：数据类型[] 参数名称* 传输内容：数组的地址* */public class Demo01ArrayParam &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; System.out.println(array); System.out.println(\"====================\"); arrayPrint(array); &#125; // 定义数组作为参数，遍历数组的方法 public static void arrayPrint(int[] array)&#123; System.out.println(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 数组作为方法的返回值 1234567891011121314151617181920212223/* * 数组作为方法的返回值 * 方法定义个格式： public static 数组类型[] 函数名称（）&#123;&#125; * 返回内容；数组的地址类型*/public class Demo02ArrayReturn &#123; public static void main(String[] args) &#123; int[] array = calculate(2,4); System.out.println(array); System.out.println(array[0]); System.out.println(array[1]); &#125; // 定义方法 public static int[] calculate(int a, int b) &#123; int sum = a + b; int ave = sum / 2; int[] array = &#123;sum, ave&#125;; System.out.println(array); System.out.println(\"==================\"); return array; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"yilia主题优化日志","slug":"yilia主题优化日志（持续更新）","date":"2020-05-02T04:52:29.258Z","updated":"2020-05-04T17:17:31.435Z","comments":true,"path":"2020/05/02/yilia主题优化日志（持续更新）/","link":"","permalink":"http://yoursite.com/2020/05/02/yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法","text":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法 一. 所有文章 功能刚clone的yilia主题左边的所有文章功能不能用，要进行一下操作 在博客根目录下执行命令 1cnpm i hexo-generator-json-content --save 在hexo的配置文件_config.yml最后添加 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 参考地址：https://blog.csdn.net/qq_32337109/article/details/78756041 二、截断文章博客内容默认是全部显示出来，这样显示全文按钮即没用又不好看。 截断标记 写博客的时候，在想要截断的地方写 1&lt;!--more--&gt; 此时就可以在这个位置截断文章了 隐藏截断标记 使用截断标记虽然可以实现截断文章的效果，但会出现一个标记，和显示全文按钮功能重复，我们可以打开yilia目录下的_config.yml文件，找到 1excerpt_link: more 把more改为空格，完成。 参考地址：https://www.jianshu.com/p/46660e506da5 三、基础设置12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述 # 站点描述keywords: # 博客关键字author: 作者 # 作者language: en # 语言timezone: '' # 时间 四、在左侧显示文章总数在 themes\\yilia\\layout_partial 文件夹下的left-col.ejs文件中 1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 后加上 123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"}]},{"title":"Hexo blog部署","slug":"Hexo blog部署","date":"2020-05-01T14:18:39.446Z","updated":"2020-05-04T17:11:23.198Z","comments":true,"path":"2020/05/01/Hexo blog部署/","link":"","permalink":"http://yoursite.com/2020/05/01/Hexo%20blog%E9%83%A8%E7%BD%B2/","excerpt":"这篇笔记记录了我开始使用博客的详细操作步骤","text":"这篇笔记记录了我开始使用博客的详细操作步骤 1. 下载安装node.js下载node.js 2.Hexo blog部署12npm install -g cnpm --registry=https://registry.npm.taobao.org //安装淘宝镜像cnpm install -g hexo-cli //安装hexo 在命令行操作的初始目录下创建文件夹 blog 12345cd blog //进入blog文件夹hexo init //创建一个博客hexo g //生成博客hexo s //在本地查看生成的blogcnpm install hexo-deployer-git --save //安装推到GitHub的插件 在GitHub上创建一个名为GitHub名.github.io的仓库，打开blog文件夹，找到并修改文件_config.yml，修改部分在底部，这是修改结果 123type: gitrepo: https://github.com/GitHub名/GitHub名.github.io.gitbranch: master 命令行 1hexo d //部署到远端 以上，hexo博客部署完成，此时https://GitHub名.github.io就可以访问自己的博客。 3.更换主题以更换yilia主题为例 yilia主题网址：https://github.com/litten/hexo-theme-yilia 12cd blog //进入blog文件夹git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 打开blog文件夹，找到并修改文件_config.yml，在的 73 行左右，可以看到配置的默认主题theme: landscape，所对应的是 themes 目录下的 landscape 目录。把landscape改为yilia。 1theme: yilia 命令行 1234hexo clean //清理hexo g //生成博客hexo s //本地查看hexo d //部署到远端 更换主题完成。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}