{"meta":{"title":"梁山好岗のBLOG","subtitle":"就算是梦话也无妨，再说给我听听吧","description":"站点描述","author":"梁山好岗","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T07:01:20.000Z","updated":"2020-05-04T07:04:46.242Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T07:01:36.000Z","updated":"2020-05-04T07:05:32.380Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-04T07:01:49.000Z","updated":"2020-05-04T07:06:03.220Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java学习日记8——Object类、常用API","slug":"Java学习日记8——Object类、常用API","date":"2020-07-11T05:51:35.570Z","updated":"2020-07-11T12:06:53.572Z","comments":true,"path":"2020/07/11/Java学习日记8——Object类、常用API/","link":"","permalink":"http://yoursite.com/2020/07/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B08%E2%80%94%E2%80%94Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/","excerpt":"Java学习每一天","text":"Java学习每一天 Object类java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; toString方法public String toString()：返回该对象的字符串表示。 用法：所用对象都可以直接调用，默认返回值是对象地址，字符串类型。 1String 变量名 = 对象名.toString(); 重写 如果不希望使用toString方法的默认返回对象地址值，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return \"Person&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 equals方法public boolean equals(Object obj)：比较两个对象是否相等 用法：所有的对象都可以直接使用，默认比较的是对象地址值是否相等，返回返回boolean类型 1boolean 变量名 = 对象名.equals(); 重写： 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name; private int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： Objects类的equals方法在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 用法：直接用Objects类调用，参数为两个需要比较的对象，返回值为boolean类型 1boolean 变量名 = Objects.equals(对象1, 对象2); 本质：还是使用了Object的equals方法，只是解决了空指针异常。 日期时间类Date类构造方法 无参构造 public Date() 12Date date = new Date(); System.out.println(date);// 当前时间，格式：Sun Aug 08 12:23:03 CST 2088 有参构造 public Date(long date) 1234// 参数是long类型Date date = new Date(0L); System.out.println(date);// 输入long类型参数毫秒对应时间，格式不变：Thu Jan 01 08:00:00 CST 1970 以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 提示1： 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 提示2：在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用成员方法public long getTime() 把日期对象转换成对应的时间毫秒值。 12// 参数：无参// 返回值类型：long 使用： 123Date date = new Date();long time = date.getTime(); System.out.println(time);//3742777636267 SimpleDateFormat类SimpleDateFormat类是抽象类DateFormat的子类 构造方法构造方法的参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则 常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。 创建SimpleDateFormat对象的代码如： 12// 对应的日期格式如：2018-01-16 15:06:38SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); 常用成员方法format方法作用：format方法配合构造方法，把时间对象转换成指定格式的字符串。 用法 12345678910/* 参数类型：Date对象; 返回值类型：String; 使用方法：String 变量名 = SimpleDateFormat对象.format(Date对象)*/ Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = df.format(date); System.out.println(str); // 2008年1月23日 parse方法作用：与format方法相反，把指定格式的字符串转换成时间对象。 用法 123456789/* 参数类型：String; 返回值类型：Date对象; 使用方法：Date 变量名 = SimpleDateFormat对象.format(String变量)*/ DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\"); String str = \"2018年12月11日\"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 Calendar类Calendar是抽象类，日历类。 创建因为Calendar为抽象类，无法直接创建对象，我们通过它的一个静态方法创建其子类对象 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 创建格式： 123// getInstance()方法创建的是子类对象，所以这里用的了多态写法// 创建出来的对象可以直接打印，打印结果是日历数据Calendar cal = Calendar.getInstance(); 静态成员变量Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） 常用成员方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 get方法public int get(int field) 作用：获取指定日历对象中字段的值 用法 123456789101112131415161718/* 参数类型：int 实际用Calendar类的静态成员变量 返回值类型 int 使用方法：int 变量名 = Calendar对象名.get(静态成员变量)*/public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); &#125; &#125; set方法public void set(int field, int value) 作用：设置日历对象中的数据 用法 123456789101112/* 参数列表：int int 两个int分别是静态成员变量和修改的值 void无返回值 使用方法：Calendar对象名.set(静态成员变量, 修改值)*/public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法public abstract void add(int field, int amount) 作用：可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。 用法 123456789101112131415/* 参数列表：int int 两个int分别是静态成员变量和指向字段增加的值 void无返回值 使用方法：Calendar对象名.add(静态成员变量, 增加值)*/public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法public Date getTime() 作用：获取日历对应的Date对象。 用法 123456789101112/* 无参数 返回值类型：Date 使用方法：Date 对象名 = Calendar对象名.getTime()*/public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 currentTimeMillis方法public static long currentTimeMillis() 作用：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 用法 1234567891011/* 无参数 返回值类型 long 使用方法：long 变量名 = System.currentTimeMillis()*/public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; arraycopy方法public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 作用：将一个数组中指定的数据拷贝到另一个数组中的指定位置。 参数列表 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 用法 1234567891011121314import java.util.Arrays;public class Demo11SystemArrayCopy &#123; public static void main(String[] args) &#123; int[] src = new int[]&#123;1,2,3,4,5&#125;; int[] dest = new int[]&#123;6,7,8,9,10&#125;; System.arraycopy( src, 0, dest, 0, 3); /*代码运行后：两个数组中的元素发生了变化 src数组元素[1,2,3,4,5] dest数组元素[1,2,3,9,10] */ &#125;&#125; StringBuilder类如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 字符串缓冲区,可以提高字符串的效率 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 12345678910public class StringBuilderDemo &#123; public static void main(String[] args) &#123; // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder(\"itcast\"); System.out.println(sb2); // itcast &#125;&#125; 常用成员方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法public StringBuilder append(...) 作用：把参数对应的字符串内容添加到StringBuilder中 用法 append方法具有多种重载形式，可以接收任意类型的参数。 123456789101112131415161718192021/* 任意类型 返回值类型：StringBuilder地址 所以不用写接收接收，且可以使用链式编程 使用方法：StringBuilder对象名.append(任意参数);*/public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); // 可以添加 任何类型 builder.append(\"hello\"); builder.append(\"world\"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append(\"hello\").append(\"world\").append(true).append(100); System.out.println(\"builder:\"+builder); // builder:helloworldtrue100 &#125;&#125; StringBuilder和String相互转换 String转StringBuilder: 可以使用StringBuilder的有参构造方法 12StringBuilder sb2 = new StringBuilder(\"itcast\");System.out.println(sb2); // itcast 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 StringBuilder转String: 可以使用StringBuilder中的toString方法 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 包装类如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱与拆箱用Integer举例： 装箱：基本数值—-&gt;包装对象 1234// 法一：使用构造函数函数Integer i = new Integer(4);// 法二：使用包装类中的valueOf方法Integer iii = Integer.valueOf(4); 拆箱：包装对象—-&gt;基本数值 123// 使用包装类中的intValue方法Integer i = new Integer(4);int num = i.intValue(); 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串之间的转换基本类型—-&gt;String 基本类型转换String总共有三种方式 123456789// 法一：直接加上\"\"。（最常用）int i1 = 100;String s1 = i1 + \"\";// 法二：使用包装类的静态方法toString(参数)。String s2 = Integer.toString(100);// 法三：String类的静态方法valueOf(参数)。String s3 = String.valueOf(100); String—-&gt;基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 12345public class Demo18WrapperParse &#123; public static void main(String[] args) &#123; int num = Integer.parseInt(\"100\"); &#125;&#125; 注意：如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记7——final、权限、内部类","slug":"Java学习日记7——final、权限、内部类","date":"2020-07-10T13:39:53.321Z","updated":"2020-07-10T15:02:36.416Z","comments":true,"path":"2020/07/10/Java学习日记7——final、权限、内部类/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07%E2%80%94%E2%80%94final%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"Java学习每一天","text":"Java学习每一天 final关键字final关键字代表最终、不可改变的。 注意事项：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 final修饰类含义：当前这个类不能有任何的子类。（太监类）。 格式： 123public final class 类名称 &#123; // ...&#125; final修饰方法含义：这个方法就是最终方法，也就是不能被覆盖重写。 格式： 123修饰符 final 返回值类型 方法名称(参数列表) &#123; // 方法体&#125; final修饰局部变量含义：变量经过一次赋值后，这个变量就不能进行更改。 格式： 1final 数据类型 变量名; final修饰成员变量含义：变量创建时赋值后，这个变量就不能进行更改。 格式： 12修饰符 final 数据类型 变量名 = 值;// 或不直接赋值，通过构造方法赋值 注意： 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 权限1234567891011/*变量使用权限Java中有四种权限修饰符： public &gt; protected &gt; (default) &gt; private同一个类（我自己） YES YES YES YES同一个包（我邻居） YES YES YES NO不同包子类（我儿子） YES YES NO NO不同包非子类（陌生人） YES NO NO NO注意事项：(default)并不是关键字“default”，而是根本不写。 */ 内部类成员内部类直接定义在一个类内部的类叫做成员内部类。 格式： 123456修饰符 class 外部类名称 &#123; 修饰符 class 内部类名称 &#123; // ... &#125; // ...&#125; 注意：内用外，随意访问；外用内，需要内部类对象。 使用方法： 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。 直接方式，公式： 1外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称(); 重名： 12345678910111213141516171819// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner /*extends Object*/ &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 局部变量，就近原则 System.out.println(this.num); // 内部类的成员变量 System.out.println(Outer.this.num); // 外部类的成员变量 &#125; &#125;&#125; 局部内部类如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 格式： 1234567修饰符 class 外部类名称 &#123; 修饰符 返回值类型 外部类方法名称(参数列表) &#123; class 局部内部类名称 &#123; // ... &#125; &#125;&#125; 注意：局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。 使用方法：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 权限： 123456小节一下类的权限修饰符：public &gt; protected &gt; (default) &gt; private定义一个类的时候，权限修饰符规则：1. 外部类：public / (default)2. 成员内部类：public / protected / (default) / private3. 局部内部类：什么都不能写 匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。 格式： 123接口名称 对象名 = new 接口名称() &#123; // 覆盖重写所有抽象方法&#125;; 类和接口的使用类作为成员变量类型原理：实际上类创建的对象做成员变量 举例： 创建武器类Weapon 12345678910111213141516171819public class Weapon &#123; private String code; // 武器的代号 public Weapon() &#123; &#125; public Weapon(String code) &#123; this.code = code; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125;&#125; 创建英雄类Hero 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 游戏当中的英雄角色类public class Hero &#123; private String name; // 英雄的名字 private int age; // 英雄的年龄 private Weapon weapon; // 英雄的武器 public Hero() &#123; &#125; public Hero(String name, int age, Weapon weapon) &#123; this.name = name; this.age = age; this.weapon = weapon; &#125; public void attack() &#123; System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" + weapon.getCode() + \"攻击敌方。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Weapon getWeapon() &#123; return weapon; &#125; public void setWeapon(Weapon weapon) &#123; this.weapon = weapon; &#125;&#125; 创建Main 123456789101112131415161718public class DemoMain &#123; public static void main(String[] args) &#123; // 创建一个英雄角色 Hero hero = new Hero(); // 为英雄起一个名字，并且设置年龄 hero.setName(\"盖伦\"); hero.setAge(20); // 创建一个武器对象 Weapon weapon = new Weapon(\"多兰剑\"); // 为英雄配备武器 hero.setWeapon(weapon); // 年龄为20的盖伦用多兰剑攻击敌方。 hero.attack(); &#125;&#125; 接口作为成员变量类型原理：多态写法，实际上时用多态写法创建的对象做成员变量、返回值、参数。 举例： 创建技能接口Skill 12345public interface Skill &#123; void use(); // 释放技能的抽象方法&#125; 实现技能接口SkillImpl 123456public class SkillImpl implements Skill &#123; @Override public void use() &#123; System.out.println(\"Biu~biu~biu~\"); &#125;&#125; 创建英雄类Hero 123456789101112131415161718192021222324252627282930313233343536public class Hero &#123; private String name; // 英雄的名称 private Skill skill; // 英雄的技能 public Hero() &#123; &#125; public Hero(String name, Skill skill) &#123; this.name = name; this.skill = skill; &#125; public void attack() &#123; System.out.println(\"我叫\" + name + \"，开始施放技能：\"); skill.use(); // 调用接口中的抽象方法 System.out.println(\"施放技能完成。\"); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Skill getSkill() &#123; // 接口作为返回值 return skill; &#125; public void setSkill(Skill skill) &#123; this.skill = skill; &#125;&#125; 创建Main 123456789101112131415161718192021222324252627282930public class DemoGame &#123; public static void main(String[] args) &#123; Hero hero = new Hero(); hero.setName(\"艾希\"); // 设置英雄的名称 // 设置英雄技能// hero.setSkill(new SkillImpl()); // 使用单独定义的实现类 // 还可以改成使用匿名内部类// Skill skill = new Skill() &#123;// @Override// public void use() &#123;// System.out.println(\"Pia~pia~pia~\");// &#125;// &#125;;// hero.setSkill(skill); // 进一步简化，同时使用匿名内部类和匿名对象 hero.setSkill(new Skill() &#123; @Override public void use() &#123; System.out.println(\"Biu~Pia~Biu~Pia~\"); &#125; &#125;); hero.attack(); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记6——接口、多态","slug":"Java学习日记6——接口、多态","date":"2020-07-10T06:35:42.215Z","updated":"2020-07-10T08:56:12.966Z","comments":true,"path":"2020/07/10/Java学习日记6——接口、多态/","link":"","permalink":"http://yoursite.com/2020/07/10/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B06%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/","excerpt":"Java学习每一天","text":"Java学习每一天 接口接口的创建使用创建接口 创建格式跟创建类相似，把public class 类名 换成 public interface 接口名。 在任何版本的Java中，接口都能定义抽象方法。 注意：接口是没有静态代码块或者构造方法的。 创建举例 12345678910111213141516171819202122232425262728/** 接口* 把public class 类名 换成 public interface 接口名** 在任何版本的Java中，接口都能定义抽象方法。* 格式：* public abstract 返回值类型 方法名称(参数列表);** 注意事项：* 1. 接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract* 2. 这两个关键字修饰符，可以选择性的省略。* 3. 方法的三要素，可以随意定义。* */public interface MyInterfaceAbstract &#123; // 这是一个抽象方法 public abstract void methodAbstract1(); // 这也是抽象方法 abstract void methodAbstract2(); // 这也是抽象方法 public void methodAbstract3(); // 这也是抽象方法 void methodAbstract4();&#125; 实现类 接口不能直接使用，必须有一个实现类来“实现”接口。 实现类创建格式：public class 实现类名称 implements 接口名称 { // …} 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，如果只是部分重写，那么这个类必须是抽象类。 实现上面接口 123456789101112131415161718192021public class MyInterfaceAbstractImpl implements MyInterfaceAbstract&#123; @Override public void methodAbstract1() &#123; System.out.println(\"这是第一个抽象方法\"); &#125; @Override public void methodAbstract2() &#123; System.out.println(\"这是第二个抽象方法\"); &#125; @Override public void methodAbstract3() &#123; System.out.println(\"这是第三个抽象方法\"); &#125; @Override public void methodAbstract4() &#123; System.out.println(\"这是第四个抽象方法\"); &#125;&#125; 使用举例12345678910111213141516171819202122/** 接口使用步骤：* 1. 接口不能直接使用，必须有一个“实现类”来“实现”接口。* 格式：* public class 实现类名称 implements 接口名称 &#123;* // ...* &#125;* 2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。* 实现：去掉abstract关键字，加上方法体大括号。* 3. 创建实现类的对象，进行使用。** 注意事项：* 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。* */public class Demo01Interface &#123; public static void main(String[] args) &#123; MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl(); impl.methodAbstract1(); // 这是第一个抽象方法 impl.methodAbstract2(); // 这是第二个抽象方法 &#125;&#125; default默认方法从Java 8开始，接口里允许定义默认方法。 作用：因为接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，所以如果给接口升级（添加新的抽象方法），那么已经写好的实现类都要修改，为了防止这样的麻烦，新添加的方法用默认方法，已经写好的实现类就可以直接继承了。 创建格式： 123public default 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：可以直接用实现类的对象调用。 static静态方法从Java 8开始，接口当中允许定义静态方法 创建格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 调用规则：通过接口名称，直接调用其中的静态方法。 private私有方法从Java 9开始，接口当中允许定义私有方法。 只能内部使用，不能调用； 作用：接口内的默认方法或静态方法中可能会有重复代码，如果定义新的默认方法或静态代码来减少重复代码，会导致可调用方法增多，可以通过使用私有方法，减少重复代码，又不会增加可调用方法。 私有方法用法举例： 下面创建一个接口，减少代码重复，但不增加可调用方法。 123456789101112131415161718public interface MyInterfacePrivateB &#123; public static void methodStatic1() &#123; System.out.println(\"静态方法1\"); methodStaticCommon(); &#125; public static void methodStatic2() &#123; System.out.println(\"静态方法2\"); methodStaticCommon(); &#125; private static void methodStaticCommon() &#123; System.out.println(\"AAA\"); System.out.println(\"BBB\"); System.out.println(\"CCC\"); &#125;&#125; 成员变量【常量】接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。 创建格式： 1public static final 数据类型 常量名称 = 数据值; 调用格式： 1接口名.常量名； 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 多接口 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 格式： 123public class 实现类 implements 接口1, 接口2 &#123; // 覆盖重写所有抽象方法&#125; 重名： 多继承可能会出现重名问题。 抽象方法重名 在实现类中只需要覆盖重写一次即可。 默认方法重名 实现类一定要对冲突的默认方法进行覆盖重写。 父类中方法与默认方法重名 会优先用父类当中的方法。 小结 多态代码当中体现多态性，其实就是一句话：父类引用指向子类对象。 格式1234格式：父类名称 对象名 = new 子类名称();或者：接口名称 对象名 = new 实现类名称(); 调用规则口诀： 成员变量：编译看左边，运行还看左边。 成员方法：编译看左边，运行看右边。 举例： 123456789101112131415public class Demo02MultiMethod &#123; public static void main(String[] args) &#123; Fu obj = new Zi(); // 多态 // 编译看左边，写出obj.method();，父类有method()方法，编译不报错。 // 运行看右边，在子类找method()方法，找到直接执行子类中的method方法，找不到向上找。 obj.method(); // 父子都有，优先用子 obj.methodFu(); // 子类没有，父类有，向上找到父类 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。// obj.methodZi(); // 错误写法！ &#125;&#125; 向上转型对象的向上转型，就是：父类引用指向之类对象。 向下转型向上转型一定是安全的，没有问题的，正确的。 但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。 含义：将父类对象，【还原】成本来的子类对象 格式： 12// 类似基本数据类型的强转 int a = (int) 10.6;子类名称 对象名 = (子类名称) 父类对象; 判断：如何才能知道一个父类引用的对象，本来是什么子类？ instanceof可以用来判断对象是否原本属于该子类 12对象 instanceof 类名称// 这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 判断举例： 123456789101112131415161718192021222324252627282930313233343536373839/*如何才能知道一个父类引用的对象，本来是什么子类？格式：对象 instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。 */public class Demo02Instanceof &#123; public static void main(String[] args) &#123; Animal animal = new Dog(); // 本来是一只狗 animal.eat(); // 狗吃SHIT // 如果希望掉用子类特有方法，需要向下转型 // 判断一下父类引用animal本来是不是Dog if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; // 判断一下animal本来是不是Cat if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; giveMeAPet(new Dog()); &#125; public static void giveMeAPet(Animal animal) &#123; if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.watchHouse(); &#125; if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记5——继承、super、this、抽象类","slug":"Java学习日记5——继承、super、this、抽象类","date":"2020-07-09T13:48:16.108Z","updated":"2020-07-09T14:41:39.210Z","comments":true,"path":"2020/07/09/Java学习日记5——继承、super、this、抽象类/","link":"","permalink":"http://yoursite.com/2020/07/09/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B05%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 继承继承的用法定义员工父类Employee 12345678910/** 定义父类格式（一个普通类的定义）* 定义子类格式：public class 子类名称 extends 父类名称 &#123;&#125;* */public class Employee &#123; public void method()&#123; System.out.println(\"方法执行\"); &#125;&#125; 定义Employee类的子类Teacher 12public class Teacher extends Employee &#123;&#125; 定义Employee类的子类Assistant 12public class Assistant extends Employee &#123;&#125; 使用 1234567891011121314151617public class Demo01Extends &#123; public static void main(String[] args) &#123; // 使用父类 Employee employee = new Employee(); employee.method(); //方法执行 System.out.println(\"===========\"); // 使用子类Teacher Teacher teacher = new Teacher(); teacher.method(); //方法执行 System.out.println(\"=============\"); // 使用子类Assistant Assistant assistant = new Assistant(); assistant.method(); //方法执行 &#125;&#125; 重名变量子类新定义和父类有相同的变量名 定义父类Fu 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 定义子类Zi 1234567public class Zi extends Fu &#123; int num = 200; public void ziShow()&#123; System.out.println(num); &#125;&#125; 父类和子类有重名变量num,使用结果如下 123456789101112public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Fu fu = new Fu(); fu.fuShow(); // 100 System.out.println(\"==========\"); Zi zi = new Zi(); zi.ziShow(); // 200 // fuShow在Fu类中定义，所以使用Fu类的num zi.fuShow(); // 100 &#125;&#125; 局部变量、子类变量、父类变量重名父类 1234567public class Fu &#123; public int num = 100; public void fuShow() &#123; System.out.println(num); &#125;&#125; 子类 123456789public class Zi extends Fu &#123; int num = 200; public void ziShow(int num) &#123; System.out.println(num); // 参数的num System.out.println(this.num); // 子类的num System.out.println(super.num); // 父类的num &#125;&#125; 使用结果 12345678910111213141516171819/** 变量重名问题* 局部变量 直接写变量名* 本类变量 this.变量名* 父类变量 super.变量名* */public class Demo01ExtendsField &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.ziShow(300); &#125;&#125;/*运行结果：300200100*/ 方法的重写重写：子类把继承来的方法重写一遍，添加新的功能 父类 12345678910111213public class Phone &#123; public void call() &#123; System.out.println(\"打电话\"); &#125; public void send() &#123; System.out.println(\"发短信\"); &#125; public void show() &#123; System.out.println(\"显示号码\"); &#125;&#125; 子类 1234567891011public class NewPhone extends Phone&#123; // 重写标记，建议不省略 @Override public void show() &#123; // 调用父类的show方法，节省代码 super.show(); System.out.println(\"显示头像\"); System.out.println(\"显示姓名\"); &#125;&#125; 使用结果 1234567891011121314151617181920212223242526public class Demo01OverRide &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); phone.call(); phone.send(); phone.show(); System.out.println(\"============\"); NewPhone newPhone = new NewPhone(); newPhone.call(); newPhone.send(); newPhone.show(); &#125;&#125;/*运行结果：打电话发短信显示号码============打电话发短信显示号码显示头像显示姓名*/ super的使用super代指父类 父类 12345public class Fu &#123; public Fu() &#123; System.out.println(\"父构造方法执行\"); &#125;&#125; 子类 1234567public class Zi extends Fu &#123; public Zi()&#123; // 这里自动补充super(); // super(); System.out.println(\"子构造方法执行\"); &#125;&#125; 使用及super注意 123456789101112131415161718/** 1. 子类构造方法当中有一个默认隐含的“supper()”调用，所以一定先调用的父类构造，后执行子类构造。* 2. 子类构造可以通过super关键字来调用父类重载构造。* 3. super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。* 总结：* 子类必须调用父类构造方法，不写则赠送super()，写了则用写的指定的super调用，super只能有一个，还必须是第一个。* */public class Demo01Constructor &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125;/*运行结果：父构造方法执行子构造方法执行*/ 抽象方法和抽象类抽象方法：就是加上abstract关键字，然后去掉大括号。抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可。 父类 123public abstract class Animal &#123; public abstract void eat();&#125; 子类 123456public class Cat extends Animal &#123; @Override public void eat() &#123; System.out.println(\"猫吃鱼\"); &#125;&#125; 使用结果 1234567891011121314151617/** 抽象方法：就是加上abstract关键字，然后去掉大括号* 抽象类：抽象方法所在的类，必须是抽象类才行，在class之前写上abstract即可** 如何使用抽象类和抽象方法：* 1. 不能直接创建new抽象类对象。* 2. 必须用一个子类来继承抽象父类。* 3. 子类必须覆盖重写抽象父类当中所有的抽象方法。* 4. 创建子类对象进行使用。* */public class Demo01Abstract &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.eat(); // 猫吃鱼 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记4——String类、static、Arrays类、Math类","slug":"Java学习日记4——String类、static、Arrays类、Math类","date":"2020-07-08T13:19:58.449Z","updated":"2020-07-09T07:44:08.654Z","comments":true,"path":"2020/07/08/Java学习日记4——String类、static、Arrays类、Math类/","link":"","permalink":"http://yoursite.com/2020/07/08/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B04%E2%80%94%E2%80%94String%E7%B1%BB%E3%80%81static%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 String类String类的创建 创建方法 12345678910111213141516171819202122232425262728293031323334/*String类String类的3+1种创建方法 1. 使用空参构造 String 对象名 = new String(); 2. 根据字符数组创建字符串 String 对象名 = new String(char[] array); 3. 根据字节数组创建字符串 String 对象名 = new String(byte[] array); 4. 直接创建 String str = \"Hello\";*/public class Demo01String &#123; public static void main(String[] args) &#123; // 使用空参构造 String str1 = new String(); System.out.println(\"第一个字符串：\" + str1); // 第一个字符串： // 根据字符数组创建字符串 char[] charArray = &#123;'A', 'B', 'C'&#125;; String str2 = new String(charArray); System.out.println(\"第二个字符串：\" + str2); // 第二个字符串：ABC // 根据字节数组创建字符串 byte[] byteArray = &#123;97, 98, 99&#125;; String str3 = new String(byteArray); System.out.println(\"第三个字符串：\" + str3); // 第三个字符串：abc // 直接创建 String str4 = \"Hello!\"; System.out.println(str4); // Hello! &#125;&#125; 字符串常量池 1234567891011121314// 字符串常量池：程序中直接写的引号字符串，就在字符串常量池中// 对引用类型来说，==是进行【地址值】的比较public class Demo02StringPool &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false System.out.println(str2 == str3); // false &#125;&#125; String类成员方法字符串比较1234567891011121314151617181920212223242526272829/*字符串比较1. public boolean equals(Object obj) 区分大小写 用法：对象名.equals(对象名);2. public boolean equalsIgnoreCase(String str); 不区分大小写 用法：对象名.equalsIgnoreCase(对象名);*/public class Demo01StringEquals &#123; public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"abc\"; char[] charArray = &#123;'a','b','c'&#125;; String str3 = new String(charArray); System.out.println(str1.equals(str2)); // true System.out.println(str2.equals(str3)); // true String str4 = null;// System.out.println(str4.equals(\"abc\")); // 报错！ System.out.println(str2.equals(\"abc\")); // true 不推荐 System.out.println(\"abc\".equals(str3)); // true 推荐 String str5 = \"Java\"; String str6 = \"java\"; System.out.println(str5.equals(str6)); // false 区分大小写 System.out.println(str5.equalsIgnoreCase(str6)); // true 不区分大小写 &#125;&#125; 字符串——获取长度、指定位置字符、字符串位置、拼接12345678910111213141516171819202122232425262728/** String中与获取相关的方法有** public int length() 获取字符串长度* public String concat(String str) 拼接字符串，返回新的字符串* public char charAt(int index) 获取字符串指定位置的字符（从零开始数）* public int indexOf(String str) 获取参数字符串在本字符串中首次出现的位置，如果没有返回-1* */public class Demo02StringGet &#123; public static void main(String[] args) &#123; // 获取字符串长度 int length = \"hello\".length(); System.out.println(length); // 5 // 拼接字符串 String str1 = \"Hello\".concat(\" World\"); System.out.println(str1); // Hello World // 获取字符串指定位置字符 char ch = str1.charAt(2); System.out.println(ch); // 1 // 获取字符串首次出现的位置 int index = str1.indexOf(\"lo\"); System.out.println(index); // 3 &#125;&#125; 字符串截取1234567891011121314151617181920/** 字符串的截取方法** public String substring(int index) 从参数位置开始一直截取到末尾* public String substring(int begin, int end) 截取begin到end之间的字符串* 备注：[begin,end),包括左边，不包括右边* */public class Demo03Substring &#123; public static void main(String[] args) &#123; // 截取到末尾 String str1 = \"Hello World\"; String str2 = str1.substring(6); System.out.println(str2); // 指定开始结束位置 String str3 = str1.substring(4,8); System.out.println(str3); &#125;&#125; 字符串转数组、替换字符串123456789101112131415161718192021222324252627282930/** String中与转换相关的方法有** public char[] toCharArray() 将字符串拆分成字符数组返回* public byte[] getBytes() 获取当前字符串底层的字节数组* public String replace(CharSequence orderString, CharSequence newString) 替换字符串* */import java.util.Arrays;public class Demo04StringConvert &#123; public static void main(String[] args) &#123; // 转换成字符数组 char[] chars = \"Hello\".toCharArray(); System.out.println(Arrays.toString(chars)); // [H, e, l, l, o] System.out.println(chars.length); // 5 System.out.println(\"=========================\"); // 转换成字节数组 byte[] bytes = \"abc\".getBytes(); System.out.println(Arrays.toString(bytes)); // [97, 98, 99] System.out.println(bytes.length); // 3 System.out.println(\"==========================\"); // 替换字符串 String str1 = \"How do you do?\"; String str2 = str1.replace('o','*'); System.out.println(str2); // H*w d* y*u d*? &#125;&#125; 字符串分割12345678910111213141516171819202122232425/** 字符串分割方法* public String[] split(String regex) 按照参数的规则，把字符串分割成若干段** 注意事项：* split方法的参数其实是一个“正则表达式”* 如果按照英文句点“.”进行分割，必须写成“\\\\.”* */public class Demo05StringSplit &#123; public static void main(String[] args) &#123; String str1 = \"aaa,bbb,ccc\"; String[] strArray = str1.split(\",\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; System.out.println(\"======================\"); String str2 = \"jjj.ddd.ggg\"; strArray = str2.split(\"\\\\.\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125; &#125;&#125; Static静态静态的使用先定义含有静态成员变量和静态成员方法的类Student 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private int id; private String name; private int age; //静态成员变量 static String room; static int idCounter = 0; //静态成员方法 public static void show()&#123; System.out.println(\"静态成员方法\"); &#125; // 构造方法 public Student(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; public Student() &#123; &#125; // getter/setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 使用Student类 123456789101112131415161718192021// static静态成员变量中的数据共享，即该变量属于类，而不属于对象/** 1. 静态不能访问非静态* 2. 推荐静态成员变量个静态成员方法直接用类调用* 3. 静态成员方法不能使用this* */public class demo01StaticField &#123; public static void main(String[] args) &#123; Student one = new Student(\"郭靖\",19); Student.room = \"黄埔军校\"; System.out.println(\"学号：\"+one.getId()+\"，姓名：\"+one.getName()+\"，年龄：\"+one.getAge()+\"，教室：\"+Student.room); // 教室共享，学号自增 Student two = new Student(\"黄蓉\",18); System.out.println(\"学号：\"+two.getId()+\"，姓名：\"+two.getName()+\"，年龄：\"+two.getAge()+\"，教室：\"+Student.room); // 调用静态成员方法 Student.show(); // 静态成员方法 &#125;&#125; 静态代码块先定义一个含有静态代码块的类Person 12345678910public class Person &#123; // 静态代码块 static &#123; System.out.println(\"这是静态代码块\"); &#125; // 构造方法 public Person()&#123; System.out.println(\"这是构造方法\"); &#125;&#125; 使用Person类 1234567891011121314151617/** 静态代码块：static&#123;&#125;* 1. 静态代码块只在第一次使用类的时候执行一次* 2. 静态代码块先执行* 3. 典型用途：用于一次性的对静态变量赋值* */public class demo03Static &#123; public static void main(String[] args) &#123; Person one = new Person(); /* * 运行结果： * 这是静态代码块 * 这是构造方法 * */ &#125;&#125; Arrays类12345678910111213141516171819202122232425/* * java.util.Arrays是一个与数组相关的工具类 * * public static String toString(数组) 将参数数组变成字符串，格式为“[元素1,元素2,元素3.。。。]” * public static void sort(数组) 按照默认升序（从小到大）对数组排列 * 备注：1. 数字升序排列， * 2. 字符串按字母升序排列 * 3. 如果是自定义类型，那么自定义类型需要有Comparable或者Comparator接口的支持 * */import java.util.Arrays;public class Demo01Arrays &#123; public static void main(String[] args) &#123; int[] intArray = &#123;10, 20, 30&#125;; // 将数组变成字符串 String intStr = Arrays.toString(intArray); System.out.println(intStr); // [10, 20, 30] // 对数组排序 int[] array1 = &#123;2, 1, 3, 10, 6&#125;; Arrays.sort(array1); System.out.println(Arrays.toString(array1)); // [1, 2, 3, 6, 10] &#125;&#125; Math类12345678910111213141516171819202122232425262728293031/** Math是数学工具类** public static double abs(double num) 获取绝对值* public static double ceil(double num) 向上取整* public static double floor(double num) 向下取整* public static long round(double num) 四舍五入* */public class Demo03Math &#123; public static void main(String[] args) &#123; // 获取绝对值 System.out.println(Math.abs(3.14)); // 3.14 System.out.println(Math.abs(-3.14)); // 3.14 System.out.println(\"==============\"); // 向上取整 System.out.println(Math.ceil(3.14)); // 4 System.out.println(Math.ceil(-3.14)); // -3 System.out.println(\"==============\"); // 向下取整 System.out.println(Math.floor(3.14)); // 3 System.out.println(Math.floor(-3.14)); // -4 System.out.println(\"==============\"); // 四舍五入 System.out.println(Math.round(3.14)); // 3 System.out.println(Math.round(-3.14)); // -3 &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"HTML学习日记1——HTML新增属性","slug":"HTML学习日记1——HTML新增属性","date":"2020-05-14T03:52:04.049Z","updated":"2020-05-14T04:09:26.730Z","comments":true,"path":"2020/05/14/HTML学习日记1——HTML新增属性/","link":"","permalink":"http://yoursite.com/2020/05/14/HTML%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94HTML%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/","excerpt":"学习HTML每一天","text":"学习HTML每一天 h5新增标签新增内容： 标签 作用 header 头部标签 nav 导航栏 aside 侧边栏 article 内容标签 section 某个区域 footer 尾部标签 代码举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;h5新增标签&lt;/title&gt; &lt;style&gt; header&#123; background-color: pink; height: 188px; width: 800px; margin: 20px auto; border-radius: 15px; &#125; nav&#123; background-color: pink; width: 800px; height: 50px; margin: 10px auto; &#125; aside&#123; width: 500px; height: 700px; background-color: skyblue; float: left; &#125; article&#123; width: 500px; height: 700px; background-color: blueviolet; float: left; &#125; footer&#123; background-color: aquamarine; width: 100%; height: 50px; &#125; section&#123; background-color: burlywood; height: 200px; width: 200px; &#125; div:after&#123; /* 清除浮动 */ clear: both; display: block; content: \"\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;头部标签&lt;/header&gt; &lt;nav&gt;导航栏标签&lt;/nav&gt; &lt;div&gt; &lt;aside&gt;侧边栏标签&lt;/aside&gt; &lt;article&gt;内容标签 &lt;section&gt;定义文档的某个区域&lt;/section&gt; &lt;/article&gt; &lt;/div&gt; &lt;footer&gt;尾部标签&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; video和audio标签video视频标签1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;video视频标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- video视频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 poster 视频封面 width 宽度 height 高度 preload 预加载 --&gt; &lt;video src=\"../../source/video/救赎.mp4\" autoplay=\"autoplay\" muted=\"muted\" controls=\"controls\" loop=\"loop\" poster=\"../../source/img/test.png\"&gt;&lt;/video&gt; &lt;/body&gt;&lt;/html&gt; audio音频标签12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;audio音频标签&lt;/title&gt; &lt;!-- video音频标签 属性 功能 src 文件地址 autoplay 自动播放 muted 静音播放 controls 添加控制 loop 循环播放 preload 预加载 --&gt; &lt;/head&gt; &lt;body&gt; &lt;audio src=\"../../source/audio/希望之花.mp3\" autoplay=\"autoplay\" controls=\"controls\" loop=\"loop\"&gt; 当前浏览器不支持audio &lt;/audio&gt; &lt;/body&gt;&lt;/html&gt; input新增表单123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"\"&gt; &lt;ul&gt; &lt;li&gt;邮箱：&lt;input type=\"email\"&gt;&lt;/li&gt; &lt;li&gt;网址：&lt;input type=\"url\"&gt;&lt;/li&gt; &lt;li&gt;日期：&lt;input type=\"date\"&gt;&lt;/li&gt; &lt;li&gt;时间：&lt;input type=\"time\"&gt;&lt;/li&gt; &lt;li&gt;数量：&lt;input type=\"number\"&gt;&lt;/li&gt; &lt;li&gt;手机号：&lt;input type=\"tel\"&gt;&lt;/li&gt; &lt;li&gt;搜索：&lt;input type=\"search\"&gt;&lt;/li&gt; &lt;li&gt;颜色：&lt;input type=\"color\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; input新增属性1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;input新增属性&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 搜索placeholder文字格式设置 */ input::placeholder&#123; color: #8A2BE2; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;!-- 搜索框 属性 作用 required 不能为空 placeholder 框内背景文字，输入文字消失 autofocus 自动聚焦到框中 autocomplete 输入过的内容提示，默认on 注意： 设置placeholder文字格式：input::placeholder &#123;&#125; --&gt; &lt;input type=\"search\" required=\"required\" placeholder=\"搜索\" autofocus=\"autofocus\" autocomplete=\"off\" /&gt; &lt;br /&gt; &lt;!-- 添加文件表单 属性 作用 multiple 加上这个属性后，就可以一次添加多个文件了 --&gt; &lt;input type=\"file\" multiple=\"multiple\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Java学习日记3——Scanner类、Random类、ArrayList类","slug":"Java学习日记3——Scanner类、Random类、ArrayList类","date":"2020-05-13T06:42:38.515Z","updated":"2020-05-13T12:13:20.878Z","comments":true,"path":"2020/05/13/Java学习日记3——Scanner类、Random类、ArrayList类/","link":"","permalink":"http://yoursite.com/2020/05/13/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B03%E2%80%94%E2%80%94Scanner%E7%B1%BB%E3%80%81Random%E7%B1%BB%E3%80%81ArrayList%E7%B1%BB/","excerpt":"学习Java每一天","text":"学习Java每一天 Scanner类作用：接收键盘输入的内容。 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner; // 导包语句，写在类的外面，可自动生成/* * Scanner是JDK提供的一个类，详情见API。 * * 引用类型的一般使用步骤 * 1. 导包 * 导包格式：import 包路径.类名称; * 如果要使用的目标类和当前类位于同一包下，则可以省略导包语句不写。 * java.lang包下的内容不需要导包。 * 2. 创建 * 格式：类名称 对象名 = new 类名称(); * 3. 使用 * 对象名.成员方法; * */public class Demo01Scanner &#123; public static void main(String[] args) &#123; // 创建Scanner类的对象 // System.in代表从键盘输入 // 括号中不能为空，System.in是目前的固定写法。 Scanner sc = new Scanner(System.in); // 获取从键盘输入的数字 // sc.nextInt()方法用于获取从键盘输入的数字 int num = sc.nextInt(); System.out.println(\"从键盘输入的数字是：\" + num); // 获取从键盘输入的字符串 // sc.next()方法用于获取从键盘输入的字符串 String str = sc.next(); System.out.println(\"从键盘输入的字符串是：\" + str); /*-----注意：从键盘输入的都是字符串，不同的方法是将字符串转变成不同的类型------*/ &#125;&#125; 匿名对象简单使用匿名对象先创建一个Person类备用 123456789// 定义一个Person类public class Person &#123; String name; public void show() &#123; System.out.println(\"我叫：\" + name); &#125;&#125; 简单使用 1234567891011121314151617/** 匿名对象* 创建格式：new 类名();* 注意事项：匿名对象只能使用唯一的一次。* 使用建议：确定只是用一次，可以使用匿名对象。* */public class Demo01Anonymous &#123; public static void main(String[] args) &#123; Person one = new Person(); one.name = \"高圆圆\"; one.show(); System.out.println(\"===============\"); new Person().name = \"一方通行\"; new Person().show(); // 我叫：null &#125;&#125; 匿名对象与方法匿名对象做参数和返回值 123456789101112131415161718192021222324252627282930313233// 匿名对象的使用举例import java.util.Scanner;public class Demo02Anonymous &#123; public static void main(String[] args) &#123; // 直接传值 System.out.println(\"输入第一个数字：\"); int num1 = new Scanner(System.in).nextInt(); System.out.println(\"输入的数字是：\" + num1); // 匿名对象做方法的参数 methodParam(new Scanner(System.in)); // 匿名对象做返回值 Scanner sc = methodReturn(); System.out.println(\"输入第三个数字：\"); int num3 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num3); &#125; // 匿名对象参数方法 public static void methodParam(Scanner sc) &#123; System.out.println(\"输入第二个数字：\"); int num2 = sc.nextInt(); System.out.println(\"输入的数字是：\" + num2); &#125; // 匿名对象做返回值方法 public static Scanner methodReturn() &#123; return new Scanner(System.in); &#125;&#125; Random类作用：产生随机数 123456789101112131415161718192021222324252627282930313233/* * 使用Random类 * 1. 导包 * 2. 创建 * 格式：Random 对象名 = new Random(); * 3. 使用 * 格式：int 变量名 = 对象名.nextInt(); * 括号内没有参数：返回在int范围内区随机数。 * 括号内有一个参数n：返回区间[0,n)上的一个随机数（可以通过加减数字控制区间）。 * */import java.util.Random;public class Demo01Random &#123; public static void main(String[] args) &#123; // 不设定范围 Random r = new Random(); int num = r.nextInt(); System.out.println(\"得到随机数：\" + num); // 设定范围 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(10); System.out.println(\"区间[0，10)上的随机数：\" + num); &#125; // 控制区间 for (int i = 0; i &lt; 10; i++) &#123; num = r.nextInt(5) + 1; System.out.println(\"区间[1,6)上的随机数：\" + num); &#125; &#125;&#125; ArrayList类作用：代替对象数组存在 对象数组创建Person标准类 1234567891011121314151617181920212223242526272829public class Person &#123; String name; // 姓名 int age; // 年龄 // 构造方法 public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // setter/getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 创建使用对象数组 123456789101112131415161718192021// 对象数组// 创建格式：类名[] 对象名 = new 类名[元素个数]public class Demo01Array &#123; public static void main(String[] args) &#123; Person[] array = new Person[3]; // 创建对象数组 Person one = new Person(\"迪丽热巴\",18); Person two = new Person(\"古力娜扎\",28); Person three = new Person(\"马尔扎哈\",38); array[0] = one; array[1] = two; array[2] = three; System.out.println(array[0]); // 地址值 System.out.println(array[1]); // 地址值 System.out.println(array[2]); // 地址值 System.out.println(array[1].name); // 古力娜扎 &#125;&#125; ArrayList类初识ArrayList12345678910111213141516171819202122232425262728/** ArrayList类* ArrayList集合的长度是可以随时变化的* 格式：ArrayList&lt;E&gt; 对象名 = new ArrayList&lt;&gt;();* 其中&lt;E&gt;代表泛型* 泛型：也就是装在集合中的所有元素，全都是是统一类型。* 注意：* 泛型只能是引用类型，不能是基本类型。* 对于ArrayList集合来说，直接打印得到的不是地址值，而是内容* 如果为空，则打印结果为 []* */import java.util.ArrayList;public class Demo02ArrayList &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] list.add(\"赵丽颖\"); System.out.println(list); // [赵丽颖] list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] &#125;&#125; ArrayList的常用方法1234567891011121314151617181920212223242526272829303132333435363738394041/*ArrayList中常用的方法。public boolean add(E e); 向集合当中添加元素，参数的类型和泛型一致，返回值代表添加是否成功。public E get(int index); 从集合中获取元素，参数是索引编号，返回值就是对应位置的元素，索引值从0开始数。public E remove(int index); 从集合当中删除元素，参数是索引编号，返回值就是所被删除的元素，索引值从0开始数。public int size(); 获取集合中元素的个数。*/import java.util.ArrayList;public class Demo03ArrayListMethod &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); System.out.println(list); // [] // 添加元素 list.add(\"赵丽颖\"); list.add(\"迪丽热巴\"); list.add(\"古力娜扎\"); list.add(\"玛尔扎哈\"); System.out.println(list); // [赵丽颖, 迪丽热巴, 古力娜扎, 玛尔扎哈] // 获取元素 String name = list.get(2); System.out.println(\"获取到的人名：\" + name); // 获取到的人名：古力娜扎 // 删除元素 String remove = list.remove(3); System.out.println(\"被删除的人是：\" + remove); // 被删除的人是：玛尔扎哈 System.out.println(list); //[赵丽颖, 迪丽热巴, 古力娜扎] // 获取元素个数 int size = list.size(); System.out.println(size); // 3 &#125;&#125; 包装类123456789101112131415161718192021222324252627/*包装类泛型只能是引用类型，不能是基本类型。为了集合存放基本类型，可以使用包装类。基本类型 包装类（引用类型，包装类位于java.lang包下）byte Byteshort Shortint Integer 【特殊】long Longfloat Floatdouble Doublechar Character 【特殊】boolean Boolean*/import java.util.ArrayList;public class Demo05ArrayListBasic &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(100); list.add(200); list.add(300); int num = list.get(1); System.out.println(num); // 200 &#125;&#125; 集合与方法1234567891011121314151617181920212223242526272829303132333435363738// 集合做方法的参数和返回值// 用一个大集合存入20个随机数字，然后筛选其中的偶数元素，放到小集合当中。import java.util.ArrayList;import java.util.Random;public class Demo04ArrayListReturn &#123; public static void main(String[] args) &#123; Random r = new Random(); ArrayList&lt;Integer&gt; bigList = new ArrayList&lt;&gt;(); // 在大集合中放入20个随机数字 for (int i = 0; i &lt; 20; i++) &#123; int num = r.nextInt(20) + 1; // 1~20的随机数 bigList.add(num); &#125; // 调用自定义方法，定义，打印小集合 ArrayList&lt;Integer&gt; smallList = getSmallList(bigList); System.out.println(smallList); &#125; // 定义方法 // 参数和返回值都是集合 public static ArrayList&lt;Integer&gt; getSmallList(ArrayList&lt;Integer&gt; bigList) &#123; ArrayList&lt;Integer&gt; smallList = new ArrayList&lt;&gt;(); // 筛选偶数元素，放入小集合 for (int i = 0; i &lt; bigList.size(); i++) &#123; int num; if (bigList.get(i) % 2 == 0) &#123; num = bigList.get(i); smallList.add(num); &#125; &#125; return smallList; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java学习日记2——类与对象","slug":"Java学习日记2——类与对象","date":"2020-05-11T08:07:58.285Z","updated":"2020-05-11T09:35:56.160Z","comments":true,"path":"2020/05/11/Java学习日记2——类与对象/","link":"","permalink":"http://yoursite.com/2020/05/11/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B02%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"学习Java每一天","text":"学习Java每一天 JDK提供的Arrays类中的toString方法12345678910111213// 使用面向对象的方法打印数组arrayimport java.util.Arrays; // 这行代码是自动生成的，不用管。public class Demo01PrintArray &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; // JDK给我们提供的Arrays类中，有一个toString方法 // 能把数组变成我们想要的字符串 System.out.println(Arrays.toString(array)); &#125;&#125; 类与对象的定义和使用类的定义：类中有两个组成部分：成员变量，成员方法。 12345678910111213141516171819202122232425262728293031/** 类与对象：* 类是对象的模板，对象是类的实体。** 定义一个Studnet类，类有两部分组成* 成员变量：* String name; // 名字* int age; // 年龄* 成员方法：* public void eat()&#123;&#125;; // 吃饭* public void sleep() &#123;&#125;; // 睡觉* public void study() &#123;&#125;; // 学习** 注意事项：* 1. 成员变量直接定义在类当中，在方法外边。* 2. 成员方法不要写static关键字。* */public class Student &#123; String name; int age; public void eat() &#123; System.out.println(\"吃饭饭！\"); &#125;; public void sleep() &#123; System.out.println(\"睡觉觉！\"); &#125;; public void study() &#123; System.out.println(\"学习！\"); &#125;;&#125; 类的使用类的基本使用使用上面定义的类，学习类的基本使用方法 1234567891011121314151617181920212223242526272829303132/** 类的使用：* 1. 导包：也就是指出所需要的类在什么位置。* 导包格式：import 包名称.类名称* 例： import cn.itcast.day06.demo01.Student;* 注意；如果和当前类属于同一个包，则导包语句可以省略不写。* 2. 创建对象：* 类名称 对象名 = new 类名称();* 例：Student stu = new Student();* 3. 使用：* 使用成员变量：对象名.成员变量名。* 使用成员方法：对象名 成员方法名(参数)。* */public class Demo02Student &#123; public static void main(String[] args) &#123; // 1.导包 // 位于同一个包，导包可以省略 // 2.创建 Student stu = new Student(); // 3.使用 // 使用成员变量 System.out.println(stu.name); // null System.out.println(stu.age); // 0 // 使用成员方法 stu.eat(); // 吃饭饭 stu.sleep(); // 睡觉觉 stu.study(); // 学习 &#125;&#125; 对象与方法先定义一个Phone类 123456789101112131415// 定义一个手机类public class Phone &#123; String brand; // 品牌 double price; // 价格 String color; // 颜色 public void call(String who) &#123; System.out.println(\"给\" + who + \"打电话\"); &#125; public void sendMessage() &#123; System.out.println(\"群发短信\"); &#125;&#125; 下面使用上面定义的Phone类 对象可以作为方法的参数 1234567891011121314151617181920// 对象作为方法的参数// 格式：public static 返回值类型 方法名(类名 参数名)&#123;&#125;;// 参数接收到的是对象的地址值public class Demo02PhoneParam &#123; public static void main(String[] args) &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; method(one); &#125; // 定义对象为参数的方法 public static void method(Phone one)&#123; System.out.println(one.brand); System.out.println(one.price); System.out.println(one.color); &#125;&#125; 对象可以作为方法的返回值 123456789101112131415161718192021// 对象作为方法的返回值// 格式：public static 类名 方法名(参数类型 参数名)&#123;&#125;// 返回值实际上是对象的地址public class Demo03PhoneReturn &#123; public static void main(String[] args) &#123; Phone two = getPhone(); System.out.println(two.brand); System.out.println(two.price); System.out.println(two.color); &#125; // 定义返回值为对象的方法 public static Phone getPhone() &#123; Phone one = new Phone(); one.brand = \"苹果\"; one.price = 8848.0; one.color = \"玫瑰金\"; return one; &#125;&#125; 局部变量和全局变量12345678910111213141516171819202122232425262728293031/** 局部变量和全局变量的不同* 1. 定义的位置不同【重点】* 局部变量：在方法内定义。* 全局变量：载方法外部，直接在类中定义。* 2. 作用范围不同【重点】* 局部变量：只有在方法当中可以用。* 全局变量：整个类中都可以使用。* 3. 默认值不同【重点】* 局部变量：没有默认值。* 全局变量：有默认值。* 4. 内存的位置不同【了解】* 局部变量：位于栈内存。* 全局变量：位于堆内存。* 5. 生命周期不同【了解】* 局部变量：随着方法进栈而诞生，随着方法出栈而消失。* 全局变量：随着对象创建而诞生，随着对象被垃圾回收而消失。* */public class Demo01VariableDifference &#123; String name; public void methodA()&#123; int num1; int num2 = 20; System.out.println(name); // 全局变量可以在整个类中使用，且有默认值。// System.out.println(num1); // 错误！num没有默认值。 &#125; public void methodB()&#123;// System.out.println(num2); // 错误！局部变量只能在定义变量的方法内使用。 &#125;&#125; 面对对象——封装面对对象有三大特征：封装，继承，多态。 封装在Java中体现 方法就是一种封装 123456789101112131415public class Demo02Method &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 50, 6000&#125;; System.out.println(getMax(array)); &#125; // 定义一个方法，返回一个数组的最大值。 public static int getMax(int[] array) &#123; int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = max &gt; array[i] ? max : array[i]; &#125; return max; &#125;&#125; 关键字private也是一种封装 定义Person类，并将age变量加上private。并学习setter/getter方法 1234567891011121314151617181920212223242526/** 定义Person类，并将age变量加上private。** private效果：可是使加private的变量可以在类中被访问，但无法在类外被直接访问。* 间接访问private变量的方法：添加一对setter方法和getter方法。* 方法名：setter方法和getter方法的方法名格式必须为setXxx和getXxx* 作用：可以防止错误和恶意修改*/public class Person &#123; String name; // 名字 private int age; // 年龄 public void show()&#123; System.out.println(\"姓名：\"+name+\"，年龄：\"+age); &#125; public void setAge(int a)&#123; if(a&gt;=0&amp;&amp;a&lt;=100)&#123; age = a; &#125; else &#123; System.out.println(\"输入数据错误！\"); &#125; &#125; public int getAge()&#123; return age; &#125;&#125; 使用Person类，查看private的效果 1234567891011121314public class Demo03Person &#123; public static void main(String[] args) &#123; Person person = new Person(); person.show(); System.out.println(\"=================\"); person.name = \"赵丽颖\";// person.age = 18; // 错误写法！age有private修饰，无法直接访问。 person.setAge(-20); // 年龄不可以为负数，修改失败！ person.show(); System.out.println(\"=====================\"); person.setAge(18); // 修改成功。 person.show(); &#125;&#125; 注意：boolean类型的成员看变量的getter方法的方法名为isXxx。 this关键字this关键字用于解决成员方法的参数和成员变量重名的问题，下面使用this关键字定义一个Person类。 123456789101112// 定义Person类// 当成员方法中的参数和成员变量重名时，用this关键字来区分// this代指调用方法的对象public class Person &#123; String name; // 姓名 public void sayHello(String name)&#123; System.out.println(this); // 打印调用该方法的对象的地址值 System.out.println(name+\"，你好，我是\"+this.name); &#125;&#125; 可见，this在这里代指调用方法的对象。 构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243/** 构造方法：专门用来创建对象的方法（创建对象时，new后面的那个方法）。* 格式：class 类名(参数类型 参数名)&#123;* 方法体;* &#125;* 注意事项；* 1. 构造方法的名称必须和类名称一样（包括大小写）。* 2. 构造方法不写返回值类型。* 3. 不写构造方法编译器会默认赠送一个没有参数，没有方法体的构造方法。* 4. 一旦编译至少一个构造方法，编译器将不再赠送。* 5. 构造方法是可以重载的。* */public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法（无参） public Student()&#123; System.out.println(\"构造方法执行啦\"); &#125; // 构造方法（全参） public Student(String name,int age)&#123; this.name = name; this.age = age; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 标准类1234567891011121314151617181920212223242526272829303132333435363738394041/** 定义一个标准类。* 标准类四个组成部分* 1. 所有成员变量都要用private关键字修饰。* 2. 为每一对成员变量编写一对getter/setter方法* 3. 编写一个无参数的构造方法。* 4. 编写一个全参数的构造方法。** 这样标准的类也叫做Java Bean* 使用Alt+Ins组合键可以生成代码。*/public class Student &#123; private String name; // 姓名 private int age; // 年龄 // 构造方法 public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; // getter/setter方法 public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"next使用日志（扩展篇）","slug":"next使用日志（扩展篇）","date":"2020-05-04T17:49:40.577Z","updated":"2020-05-13T13:00:56.796Z","comments":true,"path":"2020/05/05/next使用日志（扩展篇）/","link":"","permalink":"http://yoursite.com/2020/05/05/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%EF%BC%88%E6%89%A9%E5%B1%95%E7%AF%87%EF%BC%89/","excerpt":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步","text":"在基本配置过next后，我想要做更多的美化和扩展，用这篇笔记记录下来我做出扩展的每一步 添加动漫小人在博客根目录下执行命令 1npm install --save hexo-helper-live2d 执行上面代码之后，变可以选择要安装的动画了，选择参考https://huaji8.top/post/live2d-plugin-2.0/ 找到自己喜欢的动画之后，执行下面命令 1npm install live2d-widget-model-koharu 注意，上面命令最后的koharu是你选择的动画名，我这里是以koharu举例 安装完成后，要想要显示出来，还需要在站点配置文件添加下面代码 1234567891011121314151617#二次元live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu # 注意这里的koharu是上面安装的动画名字 display: position: right #在屏幕上的显示位置 width: 85 #显示宽度 height: 170 #显示高度 mobile: show: false #手机端是否显示 不想再使用这个插件的时候，可以执行下面命令卸载 1npm uninstall hexo-helper-live2d 方法来源：https://blog.csdn.net/wugenqiang/article/details/88375517 调整内容宽度因为默认内容宽度太窄，代码经常会显示不全，会生成滚动条，看起来特别不方便。 找到文件Hexo/themes/next/source/css/_custom/custom.styl 在里面添加代码 123.header&#123; width: 70%; &#125; /* 80% */.container .main-inner &#123; width: 70%; &#125; /* 80% */.content-wrap &#123; width: calc(100% - 260px); &#125; 注意百分比要一致。 方法来源1：https://github.com/iissnan/hexo-theme-next/issues/759 方法来源2：https://blog.zuiyu1818.cn/posts/NexT_codewidth.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"next使用日志（问题篇）","slug":"next使用日志","date":"2020-05-04T07:47:49.916Z","updated":"2020-05-04T17:48:26.891Z","comments":true,"path":"2020/05/04/next使用日志/","link":"","permalink":"http://yoursite.com/2020/05/04/next%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/","excerpt":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。","text":"这篇笔记是参照next官方文档操作t过程中遇到的一些问题及解决方法。 菜单项的链接正常打开 去掉||前的空格才会生效 第一个斜杠代表博客主页的相对目录，写网址的话需要删除第一个 / 正常使用分类和标签按操作要求打开分类和标签的菜单项之后，发现这两个功能并不能使用，在博客根目录下执行代码 123hexo new page \"about\"hexo new page \"tags\"hexo new page \"categories\" 这三行代码会在博客根目录下的source目录中创建about、tags、categories三个文件夹，并分别创建index.md文件，分别修改这三个文件 1234567# title和date是自动生成的，只需要添加type即可，type引号内是文件名（不带扩展名）# title是博客显示的名字，如果不写，默认显示文件名# date是博客发表时间，如果不写，默认显示文件创建时间title: categoriesdate: 2018-03-02 12:33:16type: \"categories\" 点击日志错误显示侧栏下面的日志应该和归档有相同的效果，但是实际上点击日志只会显示错误代码，解决方法是找到themes/next/_config.yml 文件下将archives：/archives/ || archive 改成archives：/archives/ 未解决问题 点击日程表错误 点击站点地图错误 关于怎么写入内容 标签和分类都是英文","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"}]},{"title":"Java学习日记1——数组","slug":"Java学习日记1——数组","date":"2020-05-03T12:17:09.305Z","updated":"2020-05-11T09:13:18.965Z","comments":true,"path":"2020/05/03/Java学习日记1——数组/","link":"","permalink":"http://yoursite.com/2020/05/03/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B01%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/","excerpt":"学习Java每一天","text":"学习Java每一天 IDEA常用快捷键 快捷键 功能 Alt+Enter 导入包，自动修正代码 Ctrl+V 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标所在下面 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+向上箭头 移动当前代码 Shift+F6 修改所有同名字符 Alt+/ 代码提示 数组数组的初始化a. 数组的初始化分为 静态初始化 1234567// 一般的静态初始化int[] array0 = new int[]&#123;20, 30, 40&#125;; // 静态初始化的省略格式 int[] array1 = &#123; 5, 25, 35 &#125;; // 分成两步初始化，分成两步来写就不能使用省略格式了 int[] array2; array2 = new int[] &#123; 2, 3, 5 &#125;; 动态初始化 123456// 一般的动态初始化int[] array0 = new int[3];// 分成两步的动态初始化int[] array1;array1 = new int[3];System.out.println(array1); // 直接打印数组名称，得到数组对应的，内存地址哈希值 b. 初始化的默认值 1234567891011121314151617181920/** 使用动态初始化的时候，其中的元素将会自动拥有一个默认值，规则如下：* 1. 如果是整数类型，那么默认值为0；* 2. 如果是浮点类型，那么默认值为0。0* 3. 如果是字符类型，那么默认值为' \\u0000'；* 4. 如果是字符串类型，那么默认值为null；* 5. 如果是布尔类型，那么默认值为false*/public class Demo05ArrayUse &#123; public static void main(String[] args) &#123; int[] array = new int[3]; System.out.println(array); // 内存地址哈希值 System.out.println(array[0]); // 0 System.out.println(array[1]); // 0 System.out.println(array[2]); // 0 array[1] = 123; System.out.println(array[1]); // 123 &#125;&#125; 数组的错误 越界异常 123456789101112// 如果访问数组编号的时候，索引编号不存在，那么将会发生数组索引越界异常public class Demo01ArrayIndex &#123; public static void main(String[] args) &#123; int[] array = &#123; 5, 25, 35 &#125;; // 错误写法 // 不存在第三号元素，所以发生异常 System.out.println(array[3]); &#125;&#125; 空指针异常 123456789101112// 所有索引类型变量，都可以赋值为一个null值。但是代表其中什么都没有。/*数组必须进行new初始化才能使用其中的元素。如果只赋值了一个null，没有进行new创建那么就会发生：空指针异常 NullPointerException*/public class Demo02ArrayNull &#123; public static void main(String[] args) &#123; int[] array = null; System.out.println(array[0]); &#125;&#125; 数组与方法 数组作为方法的参数 12345678910111213141516171819202122/** 数组作为参数* 参数写法：数据类型[] 参数名称* 传输内容：数组的地址* */public class Demo01ArrayParam &#123; public static void main(String[] args) &#123; int[] array = &#123;10, 20, 30, 40, 50, 60&#125;; System.out.println(array); System.out.println(\"====================\"); arrayPrint(array); &#125; // 定义数组作为参数，遍历数组的方法 public static void arrayPrint(int[] array)&#123; System.out.println(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125;&#125; 数组作为方法的返回值 1234567891011121314151617181920212223/* * 数组作为方法的返回值 * 方法定义个格式： public static 数组类型[] 函数名称（）&#123;&#125; * 返回内容；数组的地址类型*/public class Demo02ArrayReturn &#123; public static void main(String[] args) &#123; int[] array = calculate(2,4); System.out.println(array); System.out.println(array[0]); System.out.println(array[1]); &#125; // 定义方法 public static int[] calculate(int a, int b) &#123; int sum = a + b; int ave = sum / 2; int[] array = &#123;sum, ave&#125;; System.out.println(array); System.out.println(\"==================\"); return array; &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"yilia主题优化日志","slug":"yilia主题优化日志（持续更新）","date":"2020-05-02T04:52:29.258Z","updated":"2020-05-04T17:17:31.435Z","comments":true,"path":"2020/05/02/yilia主题优化日志（持续更新）/","link":"","permalink":"http://yoursite.com/2020/05/02/yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法","text":"刚开始创建博客我使用的yilia主题，后来发现next有官方文档可以更方便地配置，换成了next主题，这是我刚开始使用yilia主题是找到的部分配置方法 一. 所有文章 功能刚clone的yilia主题左边的所有文章功能不能用，要进行一下操作 在博客根目录下执行命令 1cnpm i hexo-generator-json-content --save 在hexo的配置文件_config.yml最后添加 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 参考地址：https://blog.csdn.net/qq_32337109/article/details/78756041 二、截断文章博客内容默认是全部显示出来，这样显示全文按钮即没用又不好看。 截断标记 写博客的时候，在想要截断的地方写 1&lt;!--more--&gt; 此时就可以在这个位置截断文章了 隐藏截断标记 使用截断标记虽然可以实现截断文章的效果，但会出现一个标记，和显示全文按钮功能重复，我们可以打开yilia目录下的_config.yml文件，找到 1excerpt_link: more 把more改为空格，完成。 参考地址：https://www.jianshu.com/p/46660e506da5 三、基础设置12345678# Sitetitle: 站点标题subtitle: 站点副标题description: 站点描述 # 站点描述keywords: # 博客关键字author: 作者 # 作者language: en # 语言timezone: '' # 时间 四、在左侧显示文章总数在 themes\\yilia\\layout_partial 文件夹下的left-col.ejs文件中 1234567&lt;nav class=\"header-menu\"&gt; &lt;ul&gt; &lt;% for (var i in theme.menu)&#123; %&gt; &lt;li&gt;&lt;a href=\"&lt;%- url_for(theme.menu[i]) %&gt;\"&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/nav&gt; 后加上 123&lt;nav&gt; 总文章数 &lt;%=site.posts.length%&gt;&lt;/nav&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"}]},{"title":"Hexo blog部署","slug":"Hexo blog部署","date":"2020-05-01T14:18:39.446Z","updated":"2020-05-04T17:11:23.198Z","comments":true,"path":"2020/05/01/Hexo blog部署/","link":"","permalink":"http://yoursite.com/2020/05/01/Hexo%20blog%E9%83%A8%E7%BD%B2/","excerpt":"这篇笔记记录了我开始使用博客的详细操作步骤","text":"这篇笔记记录了我开始使用博客的详细操作步骤 1. 下载安装node.js下载node.js 2.Hexo blog部署12npm install -g cnpm --registry=https://registry.npm.taobao.org //安装淘宝镜像cnpm install -g hexo-cli //安装hexo 在命令行操作的初始目录下创建文件夹 blog 12345cd blog //进入blog文件夹hexo init //创建一个博客hexo g //生成博客hexo s //在本地查看生成的blogcnpm install hexo-deployer-git --save //安装推到GitHub的插件 在GitHub上创建一个名为GitHub名.github.io的仓库，打开blog文件夹，找到并修改文件_config.yml，修改部分在底部，这是修改结果 123type: gitrepo: https://github.com/GitHub名/GitHub名.github.io.gitbranch: master 命令行 1hexo d //部署到远端 以上，hexo博客部署完成，此时https://GitHub名.github.io就可以访问自己的博客。 3.更换主题以更换yilia主题为例 yilia主题网址：https://github.com/litten/hexo-theme-yilia 12cd blog //进入blog文件夹git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 打开blog文件夹，找到并修改文件_config.yml，在的 73 行左右，可以看到配置的默认主题theme: landscape，所对应的是 themes 目录下的 landscape 目录。把landscape改为yilia。 1theme: yilia 命令行 1234hexo clean //清理hexo g //生成博客hexo s //本地查看hexo d //部署到远端 更换主题完成。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML%E5%AD%A6%E4%B9%A0/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"hexo主题","slug":"hexo主题","permalink":"http://yoursite.com/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"next","slug":"next","permalink":"http://yoursite.com/tags/next/"},{"name":"yilia","slug":"yilia","permalink":"http://yoursite.com/tags/yilia/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}